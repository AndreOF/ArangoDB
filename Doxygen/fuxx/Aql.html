<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />


<link rel="shortcut icon" type="image/x-icon" href="http://www.arangodb.org/wp-content/themes/triagens/images/favicon.ico">

<link rel="profile" href="http://gmpg.org/xfn/11" />
<link rel="stylesheet" type="text/css" media="all" href="http://www.arangodb.org/wp-content/themes/triagens-child/style.css" />
<link rel="pingback" href="" />


<!-- This site is optimized with the Yoast WordPress SEO plugin v1.4.4 - http://yoast.com/wordpress/seo/ -->
<title>ArangoDB Manual Pages - ArangoDB</title>
<meta name="description" content="ArangoDB Manual Pages"/>
<link rel="canonical" href="http://www.arangodb.org/manualredirector" />
<meta property='og:locale' content='en_US'/>
<meta property='og:title' content='ArangoDB Manual Pages - ArangoDB'/>
<meta property='og:description' content='ArangoDB Manual Pages'/>
<meta property='og:url' content='http://www.arangodb.org/manualredirector'/>
<meta property='og:site_name' content='ArangoDB'/>
<meta property='og:type' content='article'/>
<!-- / Yoast WordPress SEO plugin. -->

<link rel="alternate" type="application/rss+xml" title="ArangoDB &raquo; Feed" href="http://www.arangodb.org/feed" />
<link rel="alternate" type="application/rss+xml" title="ArangoDB &raquo; Comments Feed" href="http://www.arangodb.org/comments/feed" />
<link rel='stylesheet' id='wordpress-popular-posts-css'  href='http://www.arangodb.org/wp-content/plugins/wordpress-popular-posts/style/wpp.css?ver=3.5.1' type='text/css' media='all' />
<link rel='stylesheet' id='wp-syntax-css-css'  href='http://www.arangodb.org/wp-content/plugins/wp-syntax/css/wp-syntax.css?ver=1.0' type='text/css' media='all' />
<script type='text/javascript' src='http://www.arangodb.org/wp-includes/js/jquery/jquery.js?ver=1.8.3'></script>
<script type='text/javascript' src='http://www.arangodb.org/wp-includes/js/comment-reply.min.js?ver=3.5.1'></script>

    <style type="text/css">
    body {
    margin-top: -28px;
    padding-bottom: 28px;
    }
    body.admin-bar #wphead {
       padding-top: 0;
    }
    body.admin-bar #footer {
       padding-bottom: 28px;
    }
<link type="text/css" media="screen" rel="stylesheet" href="http://www.arangodb.org/wp-content/plugins/tweet-blender/css/tweets.css" />

    <style media="print" type="text/css">
      div.faq_answer {display: block!important;}
      p.faq_nav {display: none;}
    </style>


</head>

<body class="page page-id-1410 page-template page-template-onecolumn-page-php">

    <div id="access" role="navigation">
        <div id="nav">
            <a href="http://www.arangodb.org/" title="ArangoDB" id="branding"><img src="/wp-content/themes/triagens/images/logo_arangob_white.gif" width="154" height="34" alt="ArangoDB"></a>
            <div class="menu-header"><ul id="menu-home" class="menu"><li id="menu-item-184" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-184"><a href="http://www.arangodb.org/">Home</a></li>
<li id="menu-item-1345" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1345"><a href="http://www.arangodb.org/try">Try it out</a></li>
<li id="menu-item-279" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-279"><a href="http://www.arangodb.org/documentation">Documentation</a></li>
<li id="menu-item-95" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95"><a href="http://www.arangodb.org/roadmap">Roadmap</a></li>
<li id="menu-item-71" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-71"><a href="http://www.arangodb.org/download">Downloads</a></li>
<li id="menu-item-1299" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1299"><a href="http://www.arangodb.org/api">Drivers</a></li>
<li id="menu-item-156" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-156"><a href="http://www.arangodb.org/blog">Blog</a></li>
</ul></div>            <div class="clear_both"></div>
        </div>
    </div><!-- #access -->

  <div id="surrounding">

    <div id="wrapper" class="hfeed">
	<div id="main">

    <div id="fullsize" class="one-column">
      <div id="content" role="main">



            <div id="post-1410" class="post-1410 page type-page status-publish hentry">
                    <h2 class="entry-title">ArangoDB Manual Pages</h2>

	  <div class="entry-content">

<link id="arangodb.css" type="text/css" href="arangodb.css" rel="stylesheet">
</div>
<div id="manual_search">
<form action="/" id="searchform" method="get" role="search">
  <div><label for="s" class="screen-reader-text">Search for:</label>
    <input type="text" id="s" name="s" value="" />
    <input type="submit" value="Search" id="searchsubmit" />
  </div>
</form>
</div>
<div class="clear_both"></div>
<hr />
<div class="arangodb">
<div>
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ArangoDB's Query Language (AQL) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> <div class="navigate"><a href="Graphs.html">prev</a> | <a href="UserManual.html">home</a> | <a href="ExtendingAql.html">next</a></div>  <div class="toc"><ul>
<li><a class="el" href="Aql.html">ArangoDB's Query Language (AQL)</a><ul>
<li><a class="el" href="Aql.html#AqlPurpose">Introduction </a></li>
<li><a class="el" href="Aql.html#AqlHowToUse">How to invoke AQL </a></li>
<li><a class="el" href="Aql.html#AqlQueryResults">Query results </a></li>
<li><a class="el" href="Aql.html#AqlBasics">Language basics </a><ul>
<li><a class="el" href="Aql.html#AqlWhitespace">Whitespace </a></li>
<li><a class="el" href="Aql.html#AqlComments">Comments </a></li>
<li><a class="el" href="Aql.html#AqlKeywords">Keywords </a></li>
<li><a class="el" href="Aql.html#AqlNames">Names </a></li>
<li><a class="el" href="Aql.html#AqlTypes">Data types </a></li>
<li><a class="el" href="Aql.html#AqlParameter">Bind parameters </a></li>
<li><a class="el" href="Aql.html#AqlTypeOrder">Type and value order </a></li>
<li><a class="el" href="Aql.html#AqlData">Accessing data from collections </a></li>
<li><a class="el" href="Aql.html#AqlOperators">Operators </a></li>
<li><a class="el" href="Aql.html#AqlFunctions">Functions </a></li>
</ul>
</li>
<li><a class="el" href="Aql.html#AqlOperations">High-level operations </a><ul>
<li><a class="el" href="Aql.html#AqlOperationFor">FOR </a></li>
<li><a class="el" href="Aql.html#AqlOperationReturn">RETURN </a></li>
<li><a class="el" href="Aql.html#AqlOperationFilter">FILTER </a></li>
<li><a class="el" href="Aql.html#AqlOperationSort">SORT </a></li>
<li><a class="el" href="Aql.html#AqlOperationLimit">LIMIT </a></li>
<li><a class="el" href="Aql.html#AqlOperationLet">LET </a></li>
<li><a class="el" href="Aql.html#AqlOperationCollect">COLLECT </a></li>
</ul>
</li>
<li><a class="el" href="Aql.html#AqlAdvanced">Advanced features </a><ul>
<li><a class="el" href="Aql.html#AqlSubqueries">Subqueries </a></li>
<li><a class="el" href="Aql.html#AqlExpansion">Variable expansion </a> </li>
</ul>
</li>
</ul>
</li>
</ul>
  </div> <h2><a class="anchor" id="AqlPurpose"></a>
Introduction </h2>
<p>The ArangoDB query language (AQL) can be used to retrieve data that is stored in ArangoDB. The general workflow when executing a query is as follows:</p>
<ul>
<li>a client application ships an AQL query to the ArangoDB server. The query text contains everything ArangoDB needs to compile the result set.</li>
<li>ArangoDB will parse the query, execute it and compile the results. If the query is invalid or cannot be executed, the server will return an error that the client can process and react to. If the query can be executed successfully, the server will return the query results to the client</li>
</ul>
<p>AQL is mainly a declarative language, meaning that in a query it is expressed what result should be achieved and not how. AQL aims to be human- readable and therefore uses keywords from the English language. Another design goal of AQL was client independency, meaning that the language and syntax are the same for all clients, no matter what programming language the clients might use. Further design goals of AQL were to support complex query patterns, and to support the different data models ArangoDB offers.</p>
<p>In its purpose, AQL is similar to the Structured Query Language (SQL), but the two languages have major syntactic differences. Furthermore, to avoid any confusion between the two languages, the keywords in AQL have been chosen to be different from the keywords used in SQL.</p>
<p>AQL currently supports reading data only. That means you can use the language to issue read-requests on your database, but modifying data via AQL is currently not supported.</p>
<p>For some example queries, please refer to the page <a class="el" href="AqlExamples.html">AQL Examples</a>.</p>
<h2><a class="anchor" id="AqlHowToUse"></a>
How to invoke AQL </h2>
<p>You can run AQL queries from your application via the HTTP REST API. The full API description is available at <a class="el" href="HttpCursor.html">HTTP Interface for AQL Query Cursors</a>.</p>
<p>You can also run AQL queries from arangosh. To do so, first create an ArangoStatement object as follows: </p>
<pre class="fragment">arangosh&gt; stmt = db._createStatement( { "query": "FOR i IN [ 1, 2 ] RETURN i * 2" } );
[object ArangoStatement]
</pre><p>To execute the query, use the <code>execute</code> method: </p>
<pre class="fragment">arangosh&gt; c = stmt.execute();
[object ArangoQueryCursor]
</pre><p>This has executed the query. The query results are available in a cursor now. The cursor can return all its results at once using the <code>toArray</code> method. This is a short-cut that you can use if you want to access the full result set without iterating over it yourself. </p>
<pre class="fragment">arangosh&gt; c.toArray();
[2, 4]
</pre><p>Cursors can also be used to iterate over the result set document-by-document. To do so, use the <code>hasNext</code> and <code>next</code> methods of the cursor: </p>
<pre class="fragment">arangosh&gt; while (c.hasNext()) { require("internal").print(c.next()); }
2
4
</pre><p>Please note that you can iterate over the results of a cursor only once, and that the cursor will be empty when you have fully iterated over it. To iterate over the results again, the query needs to be re-executed.</p>
<p>Additionally, the iteration can be done in a forward-only fashion. There is no backwards iteration or random access to elements in a cursor.</p>
<p>To execute an AQL query using bind parameters, you need to create a statement first and then bind the parameters to it before execution: </p>
<pre class="fragment">arangosh&gt; stmt = db._createStatement( { "query": "FOR i IN [ @one, @two ] RETURN i * 2" } );
[object ArangoStatement]
arangosh&gt; stmt.bind("one", 1);
arangosh&gt; stmt.bind("two", 2);
arangosh&gt; c = stmt.execute();
[object ArangoQueryCursor]
</pre><p>The cursor results can then be dumped or iterated over as usual, e.g.: </p>
<pre class="fragment">arangosh&gt; c.toArray();
[2, 4]
</pre><p>or </p>
<pre class="fragment">arangosh&gt; while (c.hasNext()) { require("internal").print(c.next()); }
2
4
</pre><p>Please note that bind variables can also be passed into the <code>_createStatement</code> method directly, making it a bit more convenient: </p>
<pre class="fragment">arangosh&gt; stmt = db._createStatement( { 
  "query": "FOR i IN [ @one, @two ] RETURN i * 2", 
  "bindVars": { 
    "one": 1, 
    "two": 2 
  } 
} );
</pre><p>Cursors also optionally provide the total number of results. By default, they do not. To make the server return the total number of results, you may set the <code>count</code> attribute to <code>true</code> when creating a statement: </p>
<pre class="fragment">arangosh&gt; stmt = db._createStatement( { "query": "FOR i IN [ 1, 2, 3, 4 ] RETURN i", "count": true } );
</pre><p>After executing this query, you can use the <code>count</code> method of the cursor to get the number of total results from the result set: </p>
<pre class="fragment">arangosh&gt; c = stmt.execute();
[object ArangoQueryCursor]
arangosh&gt; c.count();
4
</pre><p>Please note that the <code>count</code> method returns nothing if you did not specifiy the <code>count</code> attribute when creating the query.</p>
<p>This is intentional so that the server may apply optimisations when executing the query and construct the result set incrementally. Incremental creating of the result sets would not be possible if the total number of results needs to be shipped to the client anyway. Therefore, the client has the choice to specify <code>count</code> and retrieve the total number of results for a query (and disable potential incremental result set creation on the server), or to not retrieve the total number of results, and allow the server to apply optimisations.</p>
<p>Please note that at the moment the server will always create the full result set for each query so specifying or omitting the <code>count</code> attribute currently does not have any impact on query execution. This might change in the future. Future versions of ArangoDB might create result sets incrementally on the server-side and might be able to apply optimisations if a result set is not fully fetched by a client.</p>
<h2><a class="anchor" id="AqlQueryResults"></a>
Query results </h2>
<h3><a class="anchor" id="AqlQueryResultsSet"></a>
Result sets </h3>
<p>The result of an AQL query is a list of values. The individual values in the result list may or may not have a homogenuous structure, depending on what is actually queried.</p>
<p>For example, when returning data from a collection with inhomogenuous documents (the individual documents in the collection have different attribute names) without modification, the result values will as well have an inhomogenuous structure. Each result value itself is a document: </p>
<pre class="fragment">FOR u IN users
  RETURN u

[ { "id" : 1, "name" : "John", "active" : false }, 
  { "age" : 32, "id" : 2, "name" : "Vanessa" }, 
  { "friends" : [ "John", "Vanessa" ], "id" : 3, "name" : "Amy" } ]
</pre><p>However, if a fixed set of attributes from the collection is queried, then the query result values will have a homogenuous structure. Each result value is still a document: </p>
<pre class="fragment">FOR u IN users
  RETURN { "id" : u.id, "name" : u.name }

[ { "id" : 1, "name" : "John" }, 
  { "id" : 2, "name" : "Vanessa" }, 
  { "id" : 3, "name" : "Amy" } ]
</pre><p>It is also possible to query just scalar values. In this case, the result set is a list of scalars, and each result value is a scalar value: </p>
<pre class="fragment">FOR u IN users
  RETURN u.id

[ 1, 2, 3 ]
</pre><p>If a query does not produce any results because no matching data can be found, it will produce an empty result list: </p>
<pre class="fragment">[ ]
</pre><h3><a class="anchor" id="AqlQueryResultsErrors"></a>
Errors </h3>
<p>Issuing an invalid query to the server will result in a parse error if the query is syntactically invalid. ArangoDB will detect such errors during query inspection and abort further processing. Instead, the error number and an error message are returned so that the errors can be fixed.</p>
<p>If a query passes the parsing stage, all collections referenced in the query will be opened. If any of the referenced collections is not present, query execution will again be aborted and an appropriate error message will be returned.</p>
<p>Executing a query might also produce run-time errors under some circumstances that cannot be predicted from inspecting the query text alone. This is because queries might use data from collections that might also be inhomogenuous. Some examples that will cause run-time errors are:</p>
<ul>
<li>division by zero: will be triggered when an attempt is made to use the value <code>0</code> as the divisor in an arithmetic division or modulus operation</li>
<li>invalid operands for arithmetic operations: will be triggered when an attempt is made to use any non-numeric values as operands in arithmetic operations. This includes unary (unary minus, unary plus) and binary operations (plus, minus, multiplication, division, and modulus)</li>
<li>invalid operands for logical operations: will be triggered when an attempt is made to use any non-boolean values as operand(s) in logical operations. This includes unary (logical not/negation), binary (logical and, logical or), and the ternary operators.</li>
</ul>
<p>Please refer to the <a class="el" href="ArangoErrors.html">Error codes and meanings</a> page for a list of error codes and meanings.</p>
<h2><a class="anchor" id="AqlBasics"></a>
Language basics </h2>
<h3><a class="anchor" id="AqlWhitespace"></a>
Whitespace </h3>
<p>Whitespace can be used in the query text to increase its readability. However, for the parser any whitespace (spaces, carriage returns, line feeds, and tab stops) does not have any special meaning except that it separates individual tokens in the query. Whitespace within strings or names must be enclosed in quotes in order to be preserved.</p>
<h3><a class="anchor" id="AqlComments"></a>
Comments </h3>
<p>Comments can be embedded at any position in a query. The text contained in the comment is ignored by the language parser. Comments cannot be nested, meaning the comment text may not contain another comment.</p>
<div class="fragment"><div class="line"><span class="doxy-comment">/* this is a comment */</span> RETURN 1</div>
<div class="line">    </div>
<div class="line"><span class="doxy-comment">/* these */</span> RETURN <span class="doxy-comment">/* are */</span> 1 <span class="doxy-comment">/* multiple */</span> + <span class="doxy-comment">/* comments */</span> 1</div>
</div><!-- fragment --><h3><a class="anchor" id="AqlKeywords"></a>
Keywords </h3>
<p>On the top level, AQL offers the following operations:</p>
<ul>
<li>FOR: list iteration</li>
<li>RETURN: results projection</li>
<li>FILTER: results filtering</li>
<li>SORT: result sorting</li>
<li>LIMIT: result slicing</li>
<li>LET: variable assignment</li>
<li>COLLECT: result grouping</li>
</ul>
<p>Each of the above operations can be initiated in a query by using a keyword of the same name. An AQL query can (and typically does) consist of multiple of the above operations.</p>
<p>An example AQL query might look like this: </p>
<pre class="fragment">FOR u IN users
  FILTER u.type == "newbie" &amp;&amp; u.active == true
  RETURN u.name
</pre><p>In this example query, the terms <code>FOR</code>, <code>FILTER</code>, and <code>RETURN</code> initiate the higher-level operation according to their name. These terms are also keywords, meaning that they have a special meaning in the language.</p>
<p>For example, the query parser will use the keywords to find out which high-level operations to execute. That also means keywords can only be used at certains locations in a query. This also makes all keywords reserved words that must not be used for other purposes than they are intended for.</p>
<p>For example, it is not possible to use a keyword as a collection or attribute name. If a collection or attribute need to have the same name as a keyword, the collection or attribute name needs to be quoted.</p>
<p>Keywords are case-insensitive, meaning they can be specified in lower, upper, or mixed case in queries. In this documentation, all keywords are written in upper case to make them distinguishable from other query parts.</p>
<p>In addition to the higher-level operations keywords, there are other keywords. The current list of keywords is:</p>
<ul>
<li>FOR</li>
<li>RETURN</li>
<li>FILTER</li>
<li>SORT</li>
<li>LIMIT</li>
<li>LET</li>
<li>COLLECT</li>
<li>ASC</li>
<li>DESC</li>
<li>IN</li>
<li>INTO</li>
<li>NULL</li>
<li>TRUE</li>
<li>FALSE</li>
</ul>
<p>Additional keywords might be added in future versions of ArangoDB.</p>
<h3><a class="anchor" id="AqlNames"></a>
Names </h3>
<p>In general, names are used to identify objects (collections, attributes, variables, and functions) in AQL queries.</p>
<p>The maximum supported length of any name is 64 bytes. Names in AQL are always case-sensitive.</p>
<p>Keywords must not be used as names. If a reserved keyword should be used as a name, the name must be enclosed in backticks. Enclosing a name in backticks allows using otherwise-reserved keywords as names. An example for this is: </p>
<pre class="fragment">FOR f IN `filter` 
  RETURN f.`sort`
</pre><p>Due to the backticks, <code>filter</code> and <code>sort</code> are interpreted as names and not as keywords here.</p>
<h4><a class="anchor" id="AqlCollectionNames"></a>
Collection names</h4>
<p>Collection names can be used in queries as they are. If a collection happens to have the same name as a keyword, the name must be enclosed in backticks.</p>
<p>Please refer to the <a class="el" href="NamingConventions.html">Naming Conventions in ArangoDB</a> about collection name naming conventions.</p>
<h4><a class="anchor" id="AqlAttributeNames"></a>
Attribute names</h4>
<p>When referring to attributes of documents from a collection, the fully qualified attribute name must be used. This is because multiple collections with ambiguous attribute names might be used in a query. To avoid any ambiguity, it is not allowed to refer to an unqualified attribute name.</p>
<p>Please refer to the <a class="el" href="NamingConventions.html">Naming Conventions in ArangoDB</a> for more information about the attribute naming conventions. </p>
<pre class="fragment">FOR u IN users
  FOR f IN friends
    FILTER u.active == true &amp;&amp; f.active == true &amp;&amp; u.id == f.userId
    RETURN u.name
</pre><p>In the above example, the attribute names <code>active</code>, <code>name</code>, <code>id</code>, and <code>userId</code> are qualified using the collection names they belong to (<code>u</code> and <code>f</code> respectively).</p>
<h4><a class="anchor" id="AqlVariableNames"></a>
Variable names</h4>
<p>AQL offers the user to assign values to additional variables in a query. All variables that are assigned a value must have a name that is unique within the context of the query. Variable names must be different from the names of any collection name used in the same query. </p>
<pre class="fragment">FOR u IN users
  LET friends = u.friends
  RETURN { "name" : u.name, "friends" : friends }
</pre><p>In the above query, <code>users</code> is a collection name, and both <code>u</code> and <code>friends</code> are variable names. This is because the <code>FOR</code> and <code>LET</code> operations need target variables to store their intermediate results.</p>
<p>Allowed characters in variable names are the letters <code>a</code> to <code>z</code> (both in lower and upper case), the numbers <code>0</code> to <code>9</code> and the underscore (<code>_</code>) symbol. A variable name must not start with a number. If a variable name starts with the underscore character, it must also contain at least one letter (a-z or A-Z).</p>
<h3><a class="anchor" id="AqlTypes"></a>
Data types </h3>
<p>AQL supports both primitive and compound data types. The following types are available:</p>
<ul>
<li>primitive types: consisting of exactly one value<ul>
<li>null: an empty value, also: the absence of a value</li>
<li>bool: boolean truth value with possible values <code>false</code> and <code>true</code></li>
<li>number: signed (real) number</li>
<li>string: UTF-8 encoded text value</li>
</ul>
</li>
<li>compound types: consisting of multiple values<ul>
<li>list: sequence of values, referred to by their positions</li>
<li>document: sequence of values, referred to by their names</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="AqlLiteralsNumber"></a>
Numeric literals</h4>
<p>Numeric literals can be integers or real values. They can optionally be signed using the <code>+</code> or <code>-</code> symbols. The scientific notation is also supported. </p>
<pre class="fragment">1
42
-1
-42
1.23
-99.99
0.1
-4.87e103
</pre><p>All numeric values are treated as 64-bit double-precision values internally. The internal format used is IEEE 754.</p>
<h4><a class="anchor" id="AqlLiteralsString"></a>
String literals</h4>
<p>String literals must be enclosed in single or double quotes. If the used quote character is to be used itself within the string literal, it must be escaped using the backslash symbol. Backslash literals themselves also be escaped using a backslash. </p>
<pre class="fragment">"yikes!"
"don't know"
"this is a \"quoted\" word"
"this is a longer string."
"the path separator on Windows is \\"

'yikes!'
'don\'t know'
'this is a longer string."
'the path separator on Windows is \\'
</pre><p>All string literals must be UTF-8 encoded. It is currently not possible to use arbitrary binary data if it is not UTF-8 encoded. A workaround to use binary data is to encode the data using base64 or other algorithms on the application side before storing, and decoding it on application side after retrieval.</p>
<h4><a class="anchor" id="AqlCompoundLists"></a>
Lists</h4>
<p>AQL supports two compound types:</p>
<ul>
<li>lists: a composition of unnamed values, each accessible by their positions</li>
<li>documents: a composition of named values, each accessible by their names</li>
</ul>
<p>The first supported compound type is the list type. Lists are effectively sequences of (unnamed/anonymous) values. Individual list elements can be accessed by their positions. The order of elements in a list is important.</p>
<p>An <code>list-declaration</code> starts with the <code>[</code> symbol and ends with the <code>]</code> symbol. A <code>list-declaration</code> contains zero or many <code>expression</code>s, seperated from each other with the <code>,</code> symbol.</p>
<p>In the easiest case, a list is empty and thus looks like: </p>
<pre class="fragment">[ ]
</pre><p>List elements can be any legal <code>expression</code> values. Nesting of lists is supported. </p>
<pre class="fragment">[ 1, 2, 3 ]
[ -99, "yikes!", [ true, [ "no"], [ ] ], 1 ]
[ [ "fox", "marshal" ] ] 
</pre><p>Individual list values can later be accesses by their positions using the <code>[]</code> accessor. The position of the accessed element must be a numeric value. Positions start at 0. It is also possible to use negative index values to access list values starting from the end of the list. This is convenient if the length of the list is unknown and access to elements at the end of the list is required. </p>
<pre class="fragment">// access 1st list element (element start at index 0)
u.friends[0]

// access 3rd list element
u.friends[2]

// access last list element 
u.friends[-1]

// access second last list element 
u.friends[-2]
</pre><h4><a class="anchor" id="AqlCompoundDocuments"></a>
Documents</h4>
<p>The other supported compound type is the document type. Documents are a composition of zero to many attributes. Each attribute is a name/value pair. Document attributes can be accessed individually by their names.</p>
<p>Document declarations start with the <code>{</code> symbol and end with the <code>}</code> symbol. A document contains zero to many attribute declarations, seperated from each other with the <code>,</code> symbol. In the simplest case, a document is empty. Its declaration would then be: </p>
<pre class="fragment">{ }
</pre><p>Each attribute in a document is a name/value pair. Name and value of an attribute are separated using the <code>:</code> symbol.</p>
<p>The attribute name is mandatory and must be specified as a quoted or unquoted string. If a keyword is to be used as an attribute name, the name must be quoted.</p>
<p>Any valid expression can be used as an attribute value. That also means nested documents can be used as attribute values </p>
<pre class="fragment">{ name : "Peter" }
{ "name" : "Vanessa", "age" : 15 }
{ "name" : "John", likes : [ "Swimming", "Skiing" ], "address" : { "street" : "Cucumber lane", "zip" : "94242" } }
</pre><p>Individual document attributes can later be accesses by their names using the <code>.</code> accessor. If a non-existing attribute is accessed, the result is <code>null</code>. </p>
<pre class="fragment">u.address.city.name
u.friends[0].name.first
</pre><h3><a class="anchor" id="AqlParameter"></a>
Bind parameters </h3>
<p>AQL supports the usage of bind parameters, thus allowing to separate the query text from literal values used in the query. It is good practice to separate the query text from the literal values because this will prevent (malicious) injection of keywords and other collection names into an existing query. This injection would be dangerous because it might change the meaning of an existing query.</p>
<p>Using bind parameters, the meaning of an existing query cannot be changed. Bind parameters can be used everywhere in a query where literals can be used.</p>
<p>The syntax for bind parameters is <code>@nameparameter</code> where <code>nameparameter</code> is the actual parameter name. The bind parameter values need to be passed along with the query when it is executed, but not as part of the query text itself. Please refer to the <a class="el" href="HttpCursor.html#HttpCursorHttp">Accessing Cursors via HTTP </a> manual section for information about how to pass the bind parameter values to the server. </p>
<pre class="fragment">FOR u IN users
  FILTER u.id == @id &amp;&amp; u.name == @nameparameter
  RETURN u
</pre><p>Bind parameter names must start with any of the letters <code>a</code> to <code>z</code> (both in lower and upper case) or a digit (<code>0</code> to <code>9</code>), and can be followed by any letter, digit, or the underscore symbol.</p>
<p>A special type of bind parameter exists for injecting collection names. This type of bind parameter has a name prefixed with an additional <code>@</code> symbol (thus when using the bind parameter in a query, two <code>@</code> symbols must be used. </p>
<pre class="fragment">FOR u IN @@collection
  FILTER u.active == true
    RETURN u
</pre><h3><a class="anchor" id="AqlTypeOrder"></a>
Type and value order </h3>
<p>When checking for equality or inequality or when determining the sort order of values, AQL uses a deterministic algorithm that takes both the data types and the actual values into account.</p>
<p>The compared operands are first compared by their data types, and only by their data values if the operands have the same data types.</p>
<p>The following type order is used when comparing data types: </p>
<pre class="fragment">null &lt; bool  &lt; number &lt; string &lt; list &lt; document
</pre><p>This means <code>null</code> is the smallest type in AQL, and <code>document</code> is the type with the highest order. If the compared operands have a different type, then the comparison result is determined and the comparison is finished.</p>
<p>For example, the boolean <code>true</code> value will always be less than any numeric or string value, any list (even an empty list) or any document. Additionally, any string value (even an empty string) will always be greater than any numeric value, a boolean value, <code>true</code>, or <code>false</code>. </p>
<pre class="fragment">null &lt; false
null &lt; true
null &lt; 0
null &lt; ''
null &lt; ' '
null &lt; '0'
null &lt; 'abc'
null &lt; [ ]
null &lt; { }

false &lt; true
false &lt; 0
false &lt; ''
false &lt; ' '
false &lt; '0'
false &lt; 'abc'
false &lt; [ ]
false &lt; { }

true &lt; 0
true &lt; ''
true &lt; ' '
true &lt; '0'
true &lt; 'abc'
true &lt; [ ]
true &lt; { }

0 &lt; ''
0 &lt; ' '
0 &lt; '0'
0 &lt; 'abc'
0 &lt; [ ]
0 &lt; { }

'' &lt; ' '
'' &lt; '0'
'' &lt; 'abc'
'' &lt; [ ]
'' &lt; { }

[ ] &lt; { }
</pre><p>If the two compared operands have the same data types, then the operands values are compared. For the primitive types (null, boolean, number, and string), the result is defined as follows:</p>
<ul>
<li>null: <code>null</code> is equal to <code>null</code></li>
<li>boolean:<code>false</code> is less than <code>true</code></li>
<li>number: numeric values are ordered by their cardinal value</li>
<li>string: string values are ordered using a localized comparison, see <a class="el" href="CommandLine.html#CommandLineDefaultLanguage">&ndash;default-language</a></li>
</ul>
<p>Note: unlike in SQL, <code>null</code> can be compared to any value, including <code>null</code> itself, without the result being converted into <code>null</code> automatically.</p>
<p>For compound, types the following special rules are applied:</p>
<p>Two list values are compared by comparing their individual elements position by position, starting at the first element. For each position, the element types are compared first. If the types are not equal, the comparison result is determined, and the comparison is finished. If the types are equal, then the values of the two elements are compared. If one of the lists is finished and the other list still has an element at a compared position, then <code>null</code> will be used as the element value of the fully traversed list.</p>
<p>If a list element is itself a compound value (a list or a document), then the comparison algorithm will check the element's sub values recursively. element's sub elements are compared recursively. </p>
<pre class="fragment">[ ] &lt; [ 0 ]
[ 1 ] &lt; [ 2 ]
[ 1, 2 ] &lt; [ 2 ]
[ 99, 99 ] &lt; [ 100 ]
[ false ] &lt; [ true ]
[ false, 1 ] &lt; [ false, '' ]
</pre><p>Two documents operands are compared by checking attribute names and value. The attribute names are compared first. Before attribute names are compared, a combined list of all attribute names from both operands is created and sorted lexicographically. This means that the order in which attributes are declared in a document is not relevant when comparing two documents.</p>
<p>The combined and sorted list of attribute names is then traversed, and the respective attributes from the two compared operands are then looked up. If one of the documents does not have an attribute with the sought name, its attribute value is considered to be <code>null</code>. Finally, the attribute value of both documents is compared using the beforementioned data type and value comparison. The comparisons are performed for all document attributes until there is an unambiguous comparison result. If an unambiguous comparison result is found, the comparison is finished. If there is no unambiguous comparison result, the two compared documents are considered equal. </p>
<pre class="fragment">{ } &lt; { "a" : 1 }
{ } &lt; { "a" : null }
{ "a" : 1 } &lt; { "a" : 2 }
{ "b" : 1 } &lt; { "a" : 0 }
{ "a" : { "c" : true } } &lt; { "a" : { "c" : 0 } }
{ "a" : { "c" : true, "a" : 0 } } &lt; { "a" : { "c" : false, "a" : 1 } }

{ "a" : 1, "b" : 2 } == { "b" : 2, "a" : 1 }
</pre><h3><a class="anchor" id="AqlData"></a>
Accessing data from collections </h3>
<p>Collection data can be accessed by specifying a collection name in a query. A collection can be understood as a list of documents, and that is how they are treated in AQL. Documents from collections are normally accessing using the <code>FOR</code> keyword. Note that when iterating over documents from a collection, the order of documents is undefined. To traverse documents in an explicit and deterministic order, the <code>SORT</code> keyword should be used in addition.</p>
<p>Data in collections is stored in documents, with each document potentially having different attributes than other documents. This is true even for documents of the same collection.</p>
<p>It is therefore quite normal to encounter documents that do not have some or all of the attributes that are queried in an AQL query. In this case, the non-existing attributes in the document will be treated as if they would exist with a value of <code>null</code>. That means that comparing a document attribute to <code>null</code> will return true if the document has the particular attribute and the attribute has a value of <code>null</code>, or that the document does not have the particular attribute at all.</p>
<p>For example, the following query will return all documents from the collection <code>users</code> that have a value of <code>null</code> in the attribute <code>name</code>, plus all documents from <code>users</code> that do not have the <code>name</code> attribute at all: </p>
<pre class="fragment">FOR u IN users
  FILTER u.name == null
  RETURN u
</pre><p>Furthermore, <code>null</code> is less than any other value (excluding <code>null</code> itself). That means documents with non-existing attributes might be included in the result when comparing attribute values with the less than or less equal operators.</p>
<p>For example, the following query with return all documents from the collection <code>users</code> that have an attribute <code>age</code> with a value less than <code>39</code>, but also all documents from the collection that do not have the attribute <code>age</code> at all. </p>
<pre class="fragment">FOR u IN users
  FILTER u.age &lt; 39
  RETURN u
</pre><p>This behavior should always be taken into account when writing queries.</p>
<h3><a class="anchor" id="AqlOperators"></a>
Operators </h3>
<p>AQL supports a number of operators that can be used in expressions. There are comparison, logical, arithmetic, and the ternary operator.</p>
<h4><a class="anchor" id="AqlOperatorsComparison"></a>
Comparison operators</h4>
<p>Comparison (or relational) operators compare two operands. They can be used with any input data types, and will return a boolean result value.</p>
<p>The following comparison operators are supported:</p>
<ul>
<li><code>==</code> equality</li>
<li><code>!=</code> inequality</li>
<li><code>&lt;</code> less than</li>
<li><code>&lt;=</code> less or equal</li>
<li><code>&gt;</code> greater than</li>
<li><code>&gt;=</code> greater or equal</li>
<li><code>in</code> test if a value is contained in a list</li>
</ul>
<p>The <code>in</code> operator expects the second operand to be of type list. All other operators accept any data types for the first and second operands.</p>
<p>Each of the comparison operators returns a boolean value if the comparison can be evaluated and returns <code>true</code> if the comparison evaluates to true, and <code>false</code> otherwise.</p>
<p>Some examples for comparison operations in AQL: </p>
<pre class="fragment">1 &gt; 0
true != null
45 &lt;= "yikes!"
65 != "65"
65 == 65
1.23 &lt; 1.32
1.5 IN [ 2, 3, 1.5 ]
</pre><h4><a class="anchor" id="AqlOperatorsLogical"></a>
Logical operators</h4>
<p>Logical operators combine two boolean operands in a logical operation and return a boolean result value.</p>
<p>The following logical operators are supported:</p>
<ul>
<li><code>&amp;&amp;</code> logical and operator</li>
<li><code>||</code> logical or operator</li>
<li><code>!</code> logical not/negation operator</li>
</ul>
<p>Some examples for logical operations in AQL: </p>
<pre class="fragment">u.age &gt; 15 &amp;&amp; u.address.city != ""
true || false
!u.isInvalid
</pre><p>The <code>&amp;&amp;</code>, <code>||</code>, and <code>!</code> operators expect their input operands to be boolean values each. If a non-boolean operand is used, the operation will fail with an error. In case all operands are valid, the result of each logical operator is a boolean value.</p>
<p>Both the <code>&amp;&amp;</code> and <code>||</code> operators use short-circuit evaluation and only evaluate the second operand if the result of the operation cannot be determined by checking the first operand alone.</p>
<h4><a class="anchor" id="AqlOperatorsArithmetic"></a>
Arithmetic operators</h4>
<p>Arithmetic operators perform an arithmetic operation on two numeric operands. The result of an arithmetic operation is again a numeric value. operators are supported:</p>
<p>AQL supports the following arithmetic operators:</p>
<ul>
<li><code>+</code> addition</li>
<li><code>-</code> subtraction</li>
<li><code>*</code> multiplication</li>
<li><code>/</code> division</li>
<li><code>%</code> modulus</li>
</ul>
<p>These operators work with numeric operands only. Invoking any of the operators with non-numeric operands will result in an error. An error will also be raised for some other edge cases as division by zero, numeric over- or underflow etc. If both operands are numeric and the computation result is also valid, the result will be returned as a numeric value.</p>
<p>The unary plus and unary minus are supported as well.</p>
<p>Some example arithmetic operations: </p>
<pre class="fragment">1 + 1
33 - 99
12.4 * 4.5
13.0 / 0.1
23 % 7
-15
+9.99
</pre><h4><a class="anchor" id="AQLOperatorTernary"></a>
Ternary operator</h4>
<p>AQL also supports a ternary operator that can be used for conditional evaluation. The ternary operator expects a boolean condition as its first operand, and it returns the result of the second operand if the condition evaluates to true, and the third operand otherwise.</p>
<p>Example: </p>
<pre class="fragment">u.age &gt; 15 || u.active == true ? u.userId : null
</pre><h4><a class="anchor" id="AQLOperatorsPrecedence"></a>
Operator precedence</h4>
<p>The operator precedence in AQL is as follows (lowest precedence first):</p>
<ul>
<li><code>? :</code> ternary operator</li>
<li><code>||</code> logical or</li>
<li><code>&amp;&amp;</code> logical and</li>
<li><code>==</code>, <code>!=</code> equality and inequality</li>
<li><code>in</code> in operator</li>
<li><code>&lt;</code>, <code>&lt;=</code>, <code>&gt;=</code>, <code>&gt;</code> less than, less equal, greater equal, greater than</li>
<li><code>+</code>, <code>-</code> addition, subtraction</li>
<li><code>*</code>, <code>/</code>, <code>%</code> multiplication, division, modulus</li>
<li><code>!</code>, <code>+</code>, <code>-</code> logical negation, unary plus, unary minus</li>
<li><code>[*]</code> expansion</li>
<li><code>()</code> function call</li>
<li><code>.</code> member access</li>
<li><code>[]</code> indexed value access</li>
</ul>
<p>The parentheses <code>(</code> and <code>)</code> can be used to enforce a different operator evaluation order.</p>
<h3><a class="anchor" id="AqlFunctions"></a>
Functions </h3>
<p>AQL supports functions to allow more complex computations. Functions can be called at any query position where an expression is allowed. The general function call syntax is: </p>
<pre class="fragment">FUNCTIONNAME(arguments)
</pre><p>where <code>FUNCTIONNAME</code> is the name of the function to be called, and <code>arguments</code> is a comma-separated list of function arguments. If a function does not need any arguments, the argument list can be left empty. However, even if the argument list is empty the parentheses around it are still mandatory to make function calls distinguishable from variable names.</p>
<p>Some example function calls: </p>
<pre class="fragment">HAS(user, "name")
LENGTH(friends)
COLLECTIONS()
</pre><p>In contrast to collection and variable names, function names are case-insensitive, i.e. <code>LENGTH(foo)</code> and <code>length(foo)</code> are equivalent.</p>
<h4><a class="anchor" id="AqlFunctionsExtending"></a>
Extending AQL</h4>
<p>Since ArangoDB 1.3, it is possible to extend AQL with user-defined functions. These functions need to be written in Javascript, and be registered before usage in a query.</p>
<p>Please refer to <a class="el" href="ExtendingAql.html">Extending AQL with User Functions</a> for more details on this.</p>
<p>By default, any function used in an AQL query will be sought in the built-in function namespace <code>_aql</code>. This is the default namespace that contains all AQL functions that are shipped with ArangoDB. To refer to a user-defined AQL function, the function name must be fully qualified to also include the user-defined namespace. The <code>:</code> symbol is used as the namespace separator: </p>
<pre class="fragment">MYGROUP:MYFUNC()

MYFUNCTIONS.MATH.RANDOM()
</pre><p>As all AQL function names, user function names are also case-insensitive.</p>
<h4><a class="anchor" id="AqlFunctionsCasting"></a>
Type cast functions</h4>
<p>As mentioned before, some of the operators expect their operands to have a certain data type. For example, the logical operators expect their operands to be boolean values, and the arithmetic operators expect their operands to be numeric values. If an operation is performed with operands of an unexpect type, the operation will fail with an error. To avoid such failures, value types can be converted explicitly in a query. This is called type casting.</p>
<p>In an AQL query, type casts are performed only upon request and not implicitly. This helps avoiding unexpected results. All type casts have to be performed by invoking a type cast function. AQL offers several type cast functions for this task. Each of the these functions takes an operand of any data type and returns a result value of type corresponding to the function name (e.g. <code>TO_NUMBER()</code> will return a number value):</p>
<ul>
<li> <span class="functionname">TO_BOOL(<span class="functionargument">value</span>) </span>: takes an input  <span class="functionargument">value</span> of any type and converts it into the appropriate boolean value as follows:<ul>
<li><code>null</code> is converted to <code>false</code>.</li>
<li>Numbers are converted to <code>true</code> if they are unequal to 0, and to <code>false</code> otherwise.</li>
<li>Strings are converted to <code>true</code> if they are non-empty, and to <code>false</code> otherwise.</li>
<li>Lists are converted to <code>true</code> if they are non-empty, and to <code>false</code> otherwise.</li>
<li>Documents are converted to <code>true</code> if they are non-empty, and to <code>false</code> otherwise.</li>
</ul>
</li>
</ul>
<ul>
<li> <span class="functionname">TO_NUMBER(<span class="functionargument">value</span>) </span>: takes an input  <span class="functionargument">value</span> of any type and converts it into a numeric value as follows:<ul>
<li><code>null</code>, <code>false</code>, lists, and documents are converted to the value <code>0</code>.</li>
<li><code>true</code> is converted to <code>1</code>.</li>
<li>Strings are converted to their numeric equivalent if the full string content is is a valid number, and to <code>0</code> otherwise.</li>
</ul>
</li>
</ul>
<ul>
<li> <span class="functionname">TO_STRING(<span class="functionargument">value</span>) </span>: takes an input  <span class="functionargument">value</span> of any type and converts it into a string value as follows:<ul>
<li><code>null</code> is converted to the string <code>"null"</code></li>
<li><code>false</code> is converted to the string <code>"false"</code>, <code>true</code> to the string <code>"true"</code></li>
<li>numbers, lists, and documents are converted to their string equivalents.</li>
</ul>
</li>
</ul>
<ul>
<li> <span class="functionname">TO_LIST(<span class="functionargument">value</span>) </span>: takes an input  <span class="functionargument">value</span> of any type and converts it into a list value as follows:<ul>
<li><code>null</code> is converted to an empty list</li>
<li>Boolean values, numbers, and strings are converted to a list containing the original value as its single element</li>
<li>Documents are converted to a list containing their attribute values as list elements</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="AqlFunctionsChecking"></a>
Type check functions</h4>
<p>AQL also offers functions to check the data type of a value at runtime. The following type check functions are available. Each of these functions takes an argument of any data type and returns true if the value has the type that is checked for, and false otherwise.</p>
<p>The following type check functions are available:</p>
<ul>
<li> <span class="functionname">IS_NULL(<span class="functionargument">value</span>) </span>: checks whether  <span class="functionargument">value</span> is a <code>null</code> value</li>
</ul>
<ul>
<li> <span class="functionname">IS_BOOL(<span class="functionargument">value</span>) </span>: checks whether  <span class="functionargument">value</span> is a boolean value</li>
</ul>
<ul>
<li> <span class="functionname">IS_NUMBER(<span class="functionargument">value</span>) </span>: checks whether  <span class="functionargument">value</span> is a numeric value</li>
</ul>
<ul>
<li> <span class="functionname">IS_STRING(<span class="functionargument">value</span>) </span>: checks whether  <span class="functionargument">value</span> is a string value</li>
</ul>
<ul>
<li> <span class="functionname">IS_LIST(<span class="functionargument">value</span>) </span>: checks whether  <span class="functionargument">value</span> is a list value</li>
</ul>
<ul>
<li> <span class="functionname">IS_DOCUMENT(<span class="functionargument">value</span>) </span>: checks whether  <span class="functionargument">value</span> is a document value</li>
</ul>
<h4><a class="anchor" id="AqlFunctionsString"></a>
String functions</h4>
<p>For string processing, AQL offers the following functions:</p>
<ul>
<li> <span class="functionname">CONCAT(<span class="functionargument">value1</span>,  <span class="functionargument">value2</span>, ...  <span class="functionargument">valuen</span>) </span>: concatenate the strings passed as in  <span class="functionargument">value1</span> to  <span class="functionargument">valuen</span>. <code>null</code> values are ignored.</li>
</ul>
<ul>
<li> <span class="functionname">CONCAT_SEPARATOR(<span class="functionargument">separator</span>,  <span class="functionargument">value1</span>,  <span class="functionargument">value2</span>, ...  <span class="functionargument">valuen</span>) </span>: concatenate the strings passed as arguments  <span class="functionargument">value1</span> to  <span class="functionargument">valuen</span> using the  <span class="functionargument">separator</span> string. <code>null</code> values are ignored.</li>
</ul>
<ul>
<li> <span class="functionname">CHAR_LENGTH(<span class="functionargument">value</span>) </span>: return the number of characters in  <span class="functionargument">value</span>. This is a synonym for  <span class="functionname">LENGTH(<span class="functionargument">value</span>) </span>.</li>
</ul>
<ul>
<li> <span class="functionname">LOWER(<span class="functionargument">value</span>) </span>: lower-case  <span class="functionargument">value</span></li>
</ul>
<ul>
<li> <span class="functionname">UPPER(<span class="functionargument">value</span>) </span>: upper-case  <span class="functionargument">value</span></li>
</ul>
<ul>
<li> <span class="functionname">SUBSTRING(<span class="functionargument">value</span>,  <span class="functionargument">offset</span>,  <span class="functionargument">length</span>) </span>: return a substring of  <span class="functionargument">value</span>, starting at  <span class="functionargument">offset</span> and with a maximum length of  <span class="functionargument">length</span> characters. Offsets start at position 0.</li>
</ul>
<ul>
<li> <span class="functionname">LEFT(<span class="functionargument">value</span>,  <span class="functionargument">LENGTH</span>) </span>: returns the  <span class="functionargument">LENGTH</span> leftmost characters of the string  <span class="functionargument">VALUE</span>.</li>
</ul>
<ul>
<li> <span class="functionname">RIGHT(<span class="functionargument">value</span>,  <span class="functionargument">LENGTH</span>) </span>: returns the  <span class="functionargument">LENGTH</span> rightmost characters of the string  <span class="functionargument">VALUE</span>.</li>
</ul>
<ul>
<li> <span class="functionname">TRIM(<span class="functionargument">value</span>,  <span class="functionargument">type</span>) </span>: returns the string  <span class="functionargument">VALUE</span> with whitespace stripped from the start and/or end. The optional  <span class="functionargument">type</span> parameter specifies from which parts of the string the whitespace is stripped:<ul>
<li> <span class="functionargument">type</span> 0 will strip whitespace from the start and end of the string</li>
<li> <span class="functionargument">type</span> 1 will strip whitespace from the start of the string only</li>
<li> <span class="functionargument">type</span> 2 will strip whitespace from the end of the string only</li>
</ul>
</li>
</ul>
<ul>
<li> <span class="functionname">REVERSE(<span class="functionargument">value</span>) </span>: returns the reverse of the string  <span class="functionargument">value</span>.</li>
</ul>
<ul>
<li> <span class="functionname">CONTAINS(<span class="functionargument">text</span>,  <span class="functionargument">search</span>,  <span class="functionargument">return-index</span>) </span>: checks whether the string  <span class="functionargument">search</span> is contained in the string  <span class="functionargument">text</span>. By default, this function returns <code>true</code> if  <span class="functionargument">search</span> is contained in  <span class="functionargument">text</span>, and <code>false</code> otherwise. By passing <code>true</code> as the third function parameter  <span class="functionargument">return-index</span>, the function will return the position of the first occurence of  <span class="functionargument">search</span> within  <span class="functionargument">text</span>, starting at offset 0, or <code>-1</code> if  <span class="functionargument">search</span> is not contained in  <span class="functionargument">text</span>.</p>
<p class="startli">The string matching performed by  <span class="functionname">CONTAINS</span> is case-sensitive.</p>
</li>
</ul>
<ul>
<li> <span class="functionname">LIKE(<span class="functionargument">text</span>,  <span class="functionargument">search</span>,  <span class="functionargument">case-insensitive</span>) </span>: checks whether the pattern  <span class="functionargument">search</span> is contained in the string  <span class="functionargument">text</span>, using wildcard matching. Returns <code>true</code> if the pattern is contained in  <span class="functionargument">text</span>, and <code>false</code> otherwise. The  <span class="functionargument">pattern</span> string can contain the wildcard characters <code>%</code> (meaning any sequence of characters) and <code>_</code> (any single character).</p>
<p class="startli">The string matching performed by  <span class="functionname">LIKE</span> is case-sensitive by default, but by passing <code>true</code> as the third parameter, the matching will be case-insensitive.</p>
<p class="startli">The value for  <span class="functionargument">search</span> cannot be a variable or a document attribute. The actual value must be present at query parse time already.</p>
</li>
</ul>
<h4><a class="anchor" id="AqlFunctionsNumeric"></a>
Numeric functions</h4>
<p>AQL offers some numeric functions for calculations. The following functions are supported:</p>
<ul>
<li> <span class="functionname">FLOOR(<span class="functionargument">value</span>) </span>: returns the integer closest but not greater to  <span class="functionargument">value</span></li>
</ul>
<ul>
<li> <span class="functionname">CEIL(<span class="functionargument">value</span>) </span>: returns the integer closest but not less than  <span class="functionargument">value</span></li>
</ul>
<ul>
<li> <span class="functionname">ROUND(<span class="functionargument">value</span>) </span>: returns the integer closest to  <span class="functionargument">value</span></li>
</ul>
<ul>
<li> <span class="functionname">ABS(<span class="functionargument">value</span>) </span>: returns the absolute part of  <span class="functionargument">value</span></li>
</ul>
<ul>
<li> <span class="functionname">SQRT(<span class="functionargument">value</span>) </span>: returns the square root of  <span class="functionargument">value</span></li>
</ul>
<ul>
<li> <span class="functionname">RAND()</span>: returns a pseudo-random number between 0 and 1</li>
</ul>
<h4><a class="anchor" id="AqlFunctionsList"></a>
List functions</h4>
<p>AQL supports the following functions to operate on list values:</p>
<ul>
<li> <span class="functionname">LENGTH(<span class="functionargument">list</span>) </span>: returns the length (number of list elements) of  <span class="functionargument">list</span>. If  <span class="functionargument">list</span> is a document, returns the number of attribute keys of the document, regardless of their values.</li>
</ul>
<ul>
<li> <span class="functionname">MIN(<span class="functionargument">list</span>) </span>: returns the smallest element of  <span class="functionargument">list</span>. <code>null</code> values are ignored. If the list is empty or only <code>null</code> values are contained in the list, the function will return <code>null</code>.</li>
</ul>
<ul>
<li> <span class="functionname">MAX(<span class="functionargument">list</span>) </span>: returns the greatest element of  <span class="functionargument">list</span>. <code>null</code> values are ignored. If the list is empty or only <code>null</code> values are contained in the list, the function will return <code>null</code>.</li>
</ul>
<ul>
<li> <span class="functionname">AVERAGE(<span class="functionargument">list</span>) </span>: returns the average (arithmetic mean) of the values in  <span class="functionargument">list</span>. This requires the elements in  <span class="functionargument">list</span> to be numbers. <code>null</code> values are ignored. If the list is empty or only <code>null</code> values are contained in the list, the function will return <code>null</code>.</li>
</ul>
<ul>
<li> <span class="functionname">SUM(<span class="functionargument">list</span>) </span>: returns the sum of the values in  <span class="functionargument">list</span>. This requires the elements in  <span class="functionargument">list</span> to be numbers. <code>null</code> values are ignored.</li>
</ul>
<ul>
<li> <span class="functionname">MEDIAN(<span class="functionargument">list</span>) </span>: returns the median value of the values in  <span class="functionargument">list</span>. This requires the elements in  <span class="functionargument">list</span> to be numbers. <code>null</code> values are ignored. If the list is empty or only <code>null</code> values are contained in the list, the function will return <code>null</code>.</li>
</ul>
<ul>
<li> <span class="functionname">VARIANCE_POPULATION(<span class="functionargument">list</span>) </span>: returns the population variance of the values in  <span class="functionargument">list</span>. This requires the elements in  <span class="functionargument">list</span> to be numbers. <code>null</code> values are ignored. If the list is empty or only <code>null</code> values are contained in the list, the function will return <code>null</code>.</li>
</ul>
<ul>
<li> <span class="functionname">VARIANCE_SAMPLE(<span class="functionargument">list</span>) </span>: returns the sample variance of the values in  <span class="functionargument">list</span>. This requires the elements in  <span class="functionargument">list</span> to be numbers. <code>null</code> values are ignored. If the list is empty or only <code>null</code> values are contained in the list, the function will return <code>null</code>.</li>
</ul>
<ul>
<li> <span class="functionname">STDDEV_POPULATION(<span class="functionargument">list</span>) </span>: returns the population standard deviation of the values in  <span class="functionargument">list</span>. This requires the elements in  <span class="functionargument">list</span> to be numbers. <code>null</code> values are ignored. If the list is empty or only <code>null</code> values are contained in the list, the function will return <code>null</code>.</li>
</ul>
<ul>
<li> <span class="functionname">STDDEV_SAMPLE(<span class="functionargument">list</span>) </span>: returns the sample standard deviation of the values in  <span class="functionargument">list</span>. This requires the elements in  <span class="functionargument">list</span> to be numbers. <code>null</code> values are ignored. If the list is empty or only <code>null</code> values are contained in the list, the function will return <code>null</code>.</li>
</ul>
<ul>
<li> <span class="functionname">REVERSE(<span class="functionargument">list</span>) </span>: returns the elements in  <span class="functionargument">list</span> in reversed order.</li>
</ul>
<ul>
<li> <span class="functionname">FIRST(<span class="functionargument">list</span>) </span>: returns the first element in  <span class="functionargument">list</span> or <code>null</code> if the list is empty.</li>
</ul>
<ul>
<li> <span class="functionname">LAST(<span class="functionargument">list</span>) </span>: returns the last element in  <span class="functionargument">list</span> or <code>null</code> if the list is empty.</li>
</ul>
<ul>
<li> <span class="functionname">UNIQUE(<span class="functionargument">list</span>) </span>: returns all unique elements in  <span class="functionargument">list</span>. To determine uniqueness, the function will use the comparison order defined in <a class="el" href="Aql.html#AqlTypeOrder">Type and value order </a>. Calling this function might return the unique elements in any order.</li>
</ul>
<ul>
<li> <span class="functionname">UNION(<span class="functionargument">list1, list2, ...</span>) </span>: returns the union of all lists specified. The function expects at least two list values as its arguments. Note: no duplicates will be removed. In order to remove duplicates, please use the <code>UNIQUE</code> function.</p>
<p class="startli">Example: RETURN UNION( [ 1, 2, 3 ], [ 1, 2 ] )</p>
<p class="startli">will produce: [ [ 1, 2, 3, 1, 2 ] ]</p>
<p class="startli">with duplicate removal:</p>
<p class="startli">RETURN UNIQUE( UNION( [ 1, 2, 3 ], [ 1, 2 ] ) )</p>
<p class="startli">will produce: [ [ 1, 2, 3 ] ]</p>
</li>
</ul>
<p>Apart from these functions, AQL also offers several language constructs (e.g. <code>FOR</code>, <code>SORT</code>, <code>LIMIT</code>, <code>COLLECT</code>) to operate on lists.</p>
<h4><a class="anchor" id="AqlFunctionsDocument"></a>
Document functions</h4>
<p>AQL supports the following functions to operate on document values:</p>
<ul>
<li> <span class="functionname">MATCHES(<span class="functionargument">document</span>,  <span class="functionargument">examples</span>,  <span class="functionargument">return-index</span>) </span>: compares the document  <span class="functionargument">document</span> against each example document provided in the list  <span class="functionargument">examples</span>. If  <span class="functionargument">document</span> matches one of the examples, <code>true</code> is returned, and if there is no match <code>false</code> will be returned. The default return value type can be changed by passing <code>true</code> as the third function parameter  <span class="functionargument">return-index</span>. Setting this flag will return the index of the example that matched (starting at offset 0), or <code>-1</code> if there was no match.</p>
<p class="startli">The comparisons will be started with the first example. All attributes of the example will be compared against the attributes of  <span class="functionargument">document</span>. If all attributes match, the comparison stops and the result is returned. If there is a mismatch, the function will continue the comparison with the next example until there are no more examples left.</p>
<p class="startli">The  <span class="functionargument">examples</span> must be a list of 1..n example documents, with any number of attributes each. Note: specifying an empty list of examples is not allowed.</p>
<p class="startli">Example usage:</p>
<p class="startli">RETURN MATCHES({ "test" : 1 }, [ { "test" : 1, "foo" : "bar" }, { "foo" : 1 }, { "test : 1 } ], true)</p>
<p class="startli">This will return <code>2</code>, because the third example matches, and because the <code>return-index</code> flag is set to <code>true</code>.</p>
</li>
</ul>
<ul>
<li> <span class="functionname">MERGE(<span class="functionargument">document1</span>,  <span class="functionargument">document2</span>, ...  <span class="functionargument">documentn</span>) </span>: merges the documents in  <span class="functionargument">document1</span> to  <span class="functionargument">documentn</span> into a single document. If document attribute keys are ambiguous, the merged result will contain the values of the documents contained later in the argument list.</p>
<p class="startli">For example, two documents with distinct attribute names can easily be merged into one:</p>
<p class="startli">RETURN MERGE( { "user1" : { "name" : "J" } }, { "user2" : { "name" : "T" } } ) [ { "user1" : { "name" : "J" }, "user2" : { "name" : "T" } } ]</p>
<p class="startli">When merging documents with identical attribute names, the attribute values of the latter documents will be used in the end result:</p>
<p class="startli">return MERGE( { "users" : { "name" : "J" } }, { "users" : { "name" : "T" } } ) [ { "users" : { "name" : "T" } } ]</p>
<p class="startli">Please note that merging will only be done for top-level attributes. If you wish to merge sub-attributes, you should consider using <code>MERGE_RECURSIVE</code> instead.</p>
</li>
</ul>
<ul>
<li> <span class="functionname">MERGE_RECURSIVE(<span class="functionargument">document1</span>,  <span class="functionargument">document2</span>, ...  <span class="functionargument">documentn</span>) </span>: recursively merges the documents in  <span class="functionargument">document1</span> to  <span class="functionargument">documentn</span> into a single document. If document attribute keys are ambiguous, the merged result will contain the values of the documents contained later in the argument list.</p>
<p class="startli">For example, two documents with distinct attribute names can easily be merged into one:</p>
<p class="startli">RETURN MERGE_RECURSIVE( { "user-1" : { "name" : "J", "livesIn" : { "city" : "LA" } } }, { "user-1" : { "age" : 42, "livesIn" : { "state" : "CA" } } } ) [ { "user-1" : { "name" : "J", "livesIn" : { "city" : "LA", "state" : "CA" }, "age" : 42 } } ]</p>
</li>
</ul>
<ul>
<li> <span class="functionname">HAS(<span class="functionargument">document</span>,  <span class="functionargument">attributename</span>) </span>: returns <code>true</code> if  <span class="functionargument">document</span> has an attribute named  <span class="functionargument">attributename</span>, and <code>false</code> otherwise.</li>
</ul>
<ul>
<li> <span class="functionname">ATTRIBUTES(<span class="functionargument">document</span>,  <span class="functionargument">removeInternal</span>,  <span class="functionargument">sort</span>) </span>: returns the attribute names of the document  <span class="functionargument">document</span> as a list. If  <span class="functionargument">removeInternal</span> is set to <code>true</code>, then all internal attributes (such as <code>_id</code>, <code>_key</code> etc.) are removed from the result. If  <span class="functionargument">sort</span> is set to <code>true</code>, then the attribute names in the result will be sorted. Otherwise they will be returned in any order.</li>
</ul>
<ul>
<li> <span class="functionname">UNSET(<span class="functionargument">document</span>,  <span class="functionargument">attributename</span>, ...) </span>: removes the attributes  <span class="functionargument">attributename</span> (can be one or many) from  <span class="functionargument">document</span>. All other attributes will be preserved. Multiple attribute names can be specified by either passing multiple individual string argument names, or by passing a list of attribute names:</p>
<p class="startli">RETURN UNSET(doc, '_id', '_key', [ 'foo', 'bar' ])</p>
</li>
</ul>
<ul>
<li> <span class="functionname">KEEP(<span class="functionargument">document</span>,  <span class="functionargument">attributename</span>, ...) </span>: keeps only the attributes  <span class="functionargument">attributename</span> (can be one or many) from  <span class="functionargument">document</span>. All other attributes will be removed from the result. Multiple attribute names can be specified by either passing multiple individual string argument names, or by passing a list of attribute names:</p>
<p class="startli">RETURN KEEP(doc, 'firstname', 'name', 'likes')</p>
</li>
</ul>
<h4><a class="anchor" id="AqlFunctionsGeo"></a>
Geo functions</h4>
<p>AQL offers the following functions to filter data based on geo indexes:</p>
<ul>
<li> <span class="functionname">NEAR(<span class="functionargument">collection</span>,  <span class="functionargument">latitude</span>,  <span class="functionargument">longitude</span>,  <span class="functionargument">limit</span>,  <span class="functionargument">distancename</span>) </span>: returns at most  <span class="functionargument">limit</span> documents from collection  <span class="functionargument">collection</span> that are near  <span class="functionargument">latitude</span> and  <span class="functionargument">longitude</span>. The result contains at most  <span class="functionargument">limit</span> documents, returned in any order. If more than  <span class="functionargument">limit</span> documents qualify, it is undefined which of the qualifying documents are returned. Optionally, the distances between the specified coordinate ( <span class="functionargument">latitude</span> and  <span class="functionargument">longitude</span>) and the document coordinates can be returned as well. To make use of that, an attribute name for the distance result has to be specified in the  <span class="functionargument">distancename</span> argument. The result documents will contain the distance value in an attribute of that name.  <span class="functionargument">limit</span> is an optional parameter since ArangoDB 1.3. If it is not specified or null, a limit value of 100 will be applied.</li>
</ul>
<ul>
<li> <span class="functionname">WITHIN(<span class="functionargument">collection</span>,  <span class="functionargument">latitude</span>,  <span class="functionargument">longitude</span>,  <span class="functionargument">radius</span>,  <span class="functionargument">distancename</span>) </span>: returns all documents from collection  <span class="functionargument">collection</span> that are within a radius of  <span class="functionargument">radius</span> around that specified coordinate ( <span class="functionargument">latitude</span> and  <span class="functionargument">longitude</span>). The order in which the result documents are returned is undefined. Optionally, the distance between the coordinate and the document coordinates can be returned as well. To make use of that, an attribute name for the distance result has to be specified in the  <span class="functionargument">distancename</span> argument. The result documents will contain the distance value in an attribute of that name.</li>
</ul>
<p>Note: these functions require the collection  <span class="functionargument">collection</span> to have at least one geo index. If no geo index can be found, calling this function will fail with an error.</p>
<h4><a class="anchor" id="AqlFunctionsFulltext"></a>
Fulltext functions</h4>
<p>AQL offers the following functions to filter data based on fulltext indexes:</p>
<ul>
<li> <span class="functionname">FULLTEXT(<span class="functionargument">collection</span>,  <span class="functionargument">attribute</span>,  <span class="functionargument">query</span>) </span>: returns all documents from collection  <span class="functionargument">collection</span> for which the attribute  <span class="functionargument">attribute</span> matches the fulltext query  <span class="functionargument">query</span>.  <span class="functionargument">query</span> is a comma-separated list of sought words (or prefixes of sought words). To distinguish between prefix searches and complete-match searches, each word can optionally be prefixed with either the <code>prefix:</code> or <code>complete:</code> qualifier. Different qualifiers can be mixed in the same query. Not specifying a qualifier for a search word will implicitly execute a complete-match search for the given word:</p>
<ul>
<li><code>FULLTEXT(emails, "body", "banana")</code> will look for the word <code>banana</code> in the attribute <code>body</code> of the collection <code>collection</code>.</li>
</ul>
<ul>
<li><code>FULLTEXT(emails, "body", "banana,orange")</code> will look for boths the words <code>banana</code> and <code>orange</code> in the mentioned attribute. Only those documents will be returned that contain both words.</li>
</ul>
<ul>
<li><code>FULLTEXT(emails, "body", "prefix:head")</code> will look for documents that contain any words starting with the prefix <code>head</code>.</li>
</ul>
<ul>
<li><code>FULLTEXT(emails, "body", "prefix:head,complete:aspirin")</code> will look for all documents that contain a word starting with the prefix <code>head</code> and that also contain the (complete) word <code>aspirin</code>. Note: specifying <code>complete</code> is optional here.</li>
</ul>
<ul>
<li><code>FULLTEXT(emails, "body", "prefix:cent,prefix:subst")</code> will look for all documents that contain a word starting with the prefix <code>cent</code> and that also contain a word starting with the prefix <code>subst</code>.</li>
</ul>
<p class="startli">If multiple search words (or prefixes) are given, then by default the results will be AND-combined, meaning only the logical intersection of all searches will be returned. It is also possible to combine partial results with a logical OR, and with a logical NOT:</p>
<ul>
<li><code>FULLTEXT(emails, "body", "+this,+text,+document")</code> will return all documents that contain all the mentioned words. Note: specifying the <code>+</code> symbols is optional here.</li>
</ul>
<ul>
<li><code>FULLTEXT(emails, "body", "banana,|apple")</code> will return all documents that contain either (or both) words <code>banana</code> or <code>apple</code>.</li>
</ul>
<ul>
<li><code>FULLTEXT(emails, "body", "banana,-apple")</code> will return all documents that contain the word <code>banana</code> but do not contain the word <code>apple</code>.</li>
</ul>
<ul>
<li><code>FULLTEXT(emails, "body", "banana,pear,-cranberry")</code> will return all documents that contain both the words <code>banana</code> and <code>pear</code> but do not contain the word <code>cranberry</code>.</li>
</ul>
<p class="startli">No precedence of logical operators will be honored in a fulltext query. The query will simply be evaluated from left to right.</p>
</li>
</ul>
<p>Note: the <code>FULLTEXT</code> function requires the collection  <span class="functionargument">collection</span> to have a fulltext index on <code>attribute</code>. If no fulltext index is available, this function will fail with an error.</p>
<h4><a class="anchor" id="AqlFunctionsGraph"></a>
Graph functions</h4>
<p>AQL has the following functions to traverse graphs:</p>
<ul>
<li> <span class="functionname">PATHS(<span class="functionargument">vertexcollection</span>,  <span class="functionargument">edgecollection</span>,  <span class="functionargument">direction</span>,  <span class="functionargument">followcycles</span>) </span>: returns a list of paths through the graph defined by the nodes in the collection  <span class="functionargument">vertexcollection</span> and edges in the collection  <span class="functionargument">edgecollection</span>. For each vertex in  <span class="functionargument">vertexcollection</span>, it will determine the paths through the graph depending on the value of  <span class="functionargument">direction</span>:</p>
<ul>
<li><code>"outbound"</code>: follow all paths that start at the current vertex and lead to another vertex</li>
<li><code>"inbound"</code>: follow all paths that lead from another vertex to the current vertex</li>
<li><code>"any"</code>: combination of <code>"outbound"</code> and <code>"inbound"</code>. The default value for  <span class="functionargument">direction</span> is <code>"outbound"</code>. If  <span class="functionargument">followcycles</span> is true, cyclic paths will be followed as well. This is turned off by default.</li>
</ul>
<p class="startli">The result of the function is a list of paths. Paths of length 0 will also be returned. Each path is a document consisting of the following attributes:</p>
<ul>
<li><code>vertices</code>: list of vertices visited along the path</li>
<li><code>edges</code>: list of edges visited along the path (might be empty)</li>
<li><code>source</code>: start vertex of path</li>
<li><code>destination</code>: destination vertex of path</li>
</ul>
</li>
</ul>
<p>Example calls: </p>
<pre class="fragment">PATHS(friends, friendrelations, "outbound", false)

FOR p IN PATHS(friends, friendrelations, "outbound") 
  FILTER p.source._id == "123456/123456" &amp;&amp; LENGTH(p.edges) == 2
  RETURN p.vertices[*].name
</pre><ul>
<li> <span class="functionname">TRAVERSAL(<span class="functionargument">vertexcollection</span>,  <span class="functionargument">edgecollection</span>,  <span class="functionargument">startVertex</span>,  <span class="functionargument">direction</span>,  <span class="functionargument">options</span>) </span>: traverses the graph described by  <span class="functionargument">vertexcollection</span> and  <span class="functionargument">edgecollection</span>, starting at the vertex identified by id  <span class="functionargument">startVertex</span>. Vertex connectivity is specified by the  <span class="functionargument">direction</span> parameter:</p>
<ul>
<li><code>"outbound"</code>: vertices are connected in <code>_from</code> to <code>_to</code> order</li>
<li><code>"inbound"</code>: vertices are connected in <code>_to</code> to <code>_from</code> order</li>
<li><code>"any"</code>: vertices are connected in both <code>_to</code> to <code>_from</code> and in <code>_from</code> to <code>_to</code> order</li>
</ul>
<p class="startli">Additional options for the traversal can be provided via the  <span class="functionargument">options</span> document:</p>
<ul>
<li><code>strategy</code>: defines the traversal strategy. Possible values are <code>depthfirst</code> and <code>breadthfirst</code>. Defaults to <code>depthfirst</code></li>
<li><code>order</code>: defines the traversal order: Possible values are <code>preorder</code> and <code>postorder</code>. Defaults to <code>preorder</code></li>
<li><code>itemOrder</code>: Defines the level item order. Can be <code>forward</code> or <code>backward</code>. Defaults to <code>forward</code></li>
<li><code>minDepth</code>: Minimum path depths for vertices to be included. This can be used to include only vertices in the result that are found after a certain minimum depth. Defaults to 0.</li>
<li><code>maxIterations</code>: Maximum number of iterations in each traversal. This number can be set to prevent endless loops in traversal of cyclic graphs. When a traversal performs as many iterations as the <code>maxIterations</code> value, the traversal will abort with an error. If <code>maxIterations</code> is not set, a server-defined value may be used.</li>
<li><code>maxDepth</code>: Maximum path depth for sub-edges expansion. This can be used to limit the depth of the traversal to a sensible amount. This should especially be used for big graphs to limit the traversal to some sensible amount, and for graphs containing cycles to prevent infinite traversals. The maximum depth defaults to 256, with the chance of this value being non-sensical. For several graphs, a much lower maximum depth is sensible, whereas for other, more list-oriented graphs a higher depth should be used.</li>
<li><code>paths</code>: if <code>true</code>, the paths encountered during the traversal will also be returned along with each traversed vertex. If <code>false</code>, only the encountered vertices will be returned.</li>
<li><code>uniqueness</code>: an optional document with the following properties:<ul>
<li><code>vertices</code>:<ul>
<li><code>none</code>: no vertex uniqueness is enforced</li>
<li><code>global</code>: a vertex may be visited at most once. This is the default.</li>
<li><code>path</code>: a vertex is visited only if not already contained in the current traversal path</li>
</ul>
</li>
<li><code>edges</code>:<ul>
<li><code>none</code>: no edge uniqueness is enforced</li>
<li><code>global</code>: an edge may be visited at most once. This is the default.</li>
<li><code>path</code>: an edge is visited only if not already contained in the current traversal path</li>
</ul>
</li>
</ul>
</li>
<li><code>followEdges</code>: an optional list of example edge documents that the traversal will expand into. If no examples are given, the traversal will follow all edges. If one or many edge examples are given. The traversal will only follow an edge if it matches at least one of the specified examples.</li>
</ul>
<p class="startli">The result of the TRAVERSAL function is a list of traversed points. Each point is a document consisting of the following properties:</p>
<ul>
<li><code>vertex</code>: the vertex at the traversal point</li>
<li><code>path</code>: The path history for the traversal point. The path is a document with the properties <code>vertices</code> and <code>edges</code>, which are both lists.</li>
</ul>
</li>
</ul>
<p>Example calls: </p>
<pre class="fragment">TRAVERSAL(friends, friendrelations, "friends/john", "outbound", {
  strategy: "depthfirst",
  order: "postorder",
  itemOrder: "backward",
  maxDepth: 6,
  trackPaths: true
})

TRAVERSAL(friends, friendrelations, "friends/john", "outbound", {
  strategy: "breadthfirst",
  order: "preorder",
  itemOrder: "forward",
  followEdges: [ { type: "knows" }, { state: "FL" } ]
})
</pre><ul>
<li> <span class="functionname">TRAVERSAL_TREE(<span class="functionargument">vertexcollection</span>,  <span class="functionargument">edgecollection</span>,  <span class="functionargument">startVertex</span>,  <span class="functionargument">direction</span>,  <span class="functionargument">connectName</span>,  <span class="functionargument">options</span>) </span>: traverses the graph described by  <span class="functionargument">vertexcollection</span> and  <span class="functionargument">edgecollection</span>, starting at the vertex identified by id  <span class="functionargument">startVertex</span> and creates a hierchical result. Vertex connectivity is establish by inserted an attribute which has the name specified via the  <span class="functionargument">connectName</span> parameter. Connected vertices will be placed in this attribute as a list.</p>
<p class="startli">The  <span class="functionargument">options</span> are the same as for the <code>TRAVERSAL</code> function, except that the result will be set up in a way that resembles a depth-first, pre-order visitation result. Thus, the <code>strategy</code> and <code>order</code> attributes of the  <span class="functionargument">options</span> attribute will be ignored.</p>
</li>
</ul>
<p>Example calls: </p>
<pre class="fragment">TREE(friends, friendrelations, "friends/john", "outbound", "likes", { 
  itemOrder: "forward"
})
</pre><p>When using one of AQL's graph functions please make sure that the graph does not contain cycles, or that you at least specify some maximum depth or uniqueness criteria for a traversal.</p>
<p>If no bounds are set, a traversal might run into an endless loop in a cyclic graph or sub-graph, and even in a non-cyclic graph, traversing far into the graph might consume a lot of processing time and memory for the result set.</p>
<ul>
<li> <span class="functionname">EDGES(<span class="functionargument">edgecollection</span>,  <span class="functionargument">startvertex</span>,  <span class="functionargument">direction</span>,  <span class="functionargument">edgeexamples</span>) </span>: return all edges connected to the vertex  <span class="functionargument">startvertex</span> as a list. The possible values for  <span class="functionargument">direction</span> are:</p>
<ul>
<li><code>outbound</code>: return all outbound edges</li>
<li><code>inbound</code>: return all inbound edges</li>
<li><code>any</code>: return outbound and inbound edges</li>
</ul>
<p class="startli">The  <span class="functionargument">edgeexamples</span> parameter can optionally be used to restrict the results to specific edge connections only. The matching is then done via the <code>MATCHES</code> function. To not restrict the result to specific connections,  <span class="functionargument">edgeexamples</span> should be left unspecified.</p>
</li>
</ul>
<p>Example calls: </p>
<pre class="fragment">EDGES(friendrelations, "friends/john", "outbound")
EDGES(friendrelations, "friends/john", "any", [ { "$label": "knows" } ])
</pre><ul>
<li> <span class="functionname">NEIGHBORS(<span class="functionargument">vertexcollection</span>,  <span class="functionargument">edgecollection</span>,  <span class="functionargument">startvertex</span>,  <span class="functionargument">direction</span>,  <span class="functionargument">edgeexamples</span>) </span>: return all neighbors that are directly connected to the vertex  <span class="functionargument">startvertex</span> as a list. The possible values for  <span class="functionargument">direction</span> are:</p>
<ul>
<li><code>outbound</code>: return all outbound edges</li>
<li><code>inbound</code>: return all inbound edges</li>
<li><code>any</code>: return outbound and inbound edges</li>
</ul>
<p class="startli">The  <span class="functionargument">edgeexamples</span> parameter can optionally be used to restrict the results to specific edge connections only. The matching is then done via the <code>MATCHES</code> function. To not restrict the result to specific connections,  <span class="functionargument">edgeexamples</span> should be left unspecified.</p>
</li>
</ul>
<p>Example calls: </p>
<pre class="fragment">NEIGHBORS(friends, friendrelations, "friends/john", "outbound")
NEIGHBORS(users, usersrelations, "users/john", "any", [ { "$label": "recommends" } ] )
</pre><h4><a class="anchor" id="AqlFunctionsControl"></a>
Control flow functions</h4>
<p>AQL offers the following functions to let the user control the flow of operations:</p>
<ul>
<li> <span class="functionname">NOT_NULL(<span class="functionargument">alternative</span>, ...) </span>: returns the first alternative that is not <code>null</code>, and <code>null</code> if all alternatives are <code>null</code> themselves.</li>
</ul>
<ul>
<li> <span class="functionname">FIRST_LIST(<span class="functionargument">alternative</span>, ...) </span>: returns the first alternative that is a list, and <code>null</code> if none of the alternatives is a list.</li>
</ul>
<ul>
<li> <span class="functionname">FIRST_DOCUMENT(<span class="functionargument">alternative</span>, ...) </span>: returns the first alternative that is a document, and <code>null</code> if none of the alternatives is a document.</li>
</ul>
<h4><a class="anchor" id="AqlFunctionsMisc"></a>
Miscellaneous functions</h4>
<p>Finally, AQL supports the following functions that do not belong to any of the other function categories:</p>
<ul>
<li> <span class="functionname">COLLECTIONS()</span>: returns a list of collections. Each collection is returned as a document with attributes <code>name</code> and <code>_id</code>.</li>
</ul>
<ul>
<li> <span class="functionname">DOCUMENT(<span class="functionargument">collection</span>,  <span class="functionargument">id</span>) </span>: returns the document that id uniquely identified by the  <span class="functionargument">id</span>. ArangoDB will try to find the document using the <code>_id</code> value of the document in the specified collection. If there is a mismatch between the  <span class="functionargument">collection</span> passed and the collection specified in  <span class="functionargument">id</span>, then no document will be returned. Additionally, if the  <span class="functionargument">collection</span> matches the collection value specified in  <span class="functionargument">id</span> but the document cannot be found, no document will be returned. This function also allows  <span class="functionargument">id</span> to be a list of ids. In this case, the function will return a list of all documents that could be found.</li>
</ul>
<h2><a class="anchor" id="AqlOperations"></a>
High-level operations </h2>
<h3><a class="anchor" id="AqlOperationFor"></a>
FOR </h3>
<p>The <code>FOR</code> keyword can be to iterate over all elements of a list. The general syntax is: </p>
<pre class="fragment">FOR variable-name IN expression
</pre><p>Each list element returned by <code>expression</code> is visited exactly once. It is required that <code>expression</code> returns a list in all cases. The empty list is allowed, too. The current list element is made available for further processing in the variable specified by <code>variable-name</code>. </p>
<pre class="fragment">FOR u IN users
  RETURN u
</pre><p>This will iterate over all elements from the list <code>users</code> (note: this list consists of all documents from the collection named "users" in this case) and make the current list element available in variable <code>u</code>. <code>u</code> is not modified in this example but simply pushed into the result using the <code>RETURN</code> keyword.</p>
<p>Note: when iterating over collection-based lists as shown here, the order of documents is undefined unless an explicit sort order is defined using a <code>SORT</code> statement.</p>
<p>The variable introduced by <code>FOR</code> is available until the scope the <code>FOR</code> is placed in is closed.</p>
<p>Another example that uses a statically declared list of values to iterate over: </p>
<pre class="fragment">FOR year IN [ 2011, 2012, 2013 ]
  RETURN { "year" : year, "isLeapYear" : year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0) }
</pre><p>Nesting of multiple <code>FOR</code> statements is allowed, too. When <code>FOR</code> statements are nested, a cross product of the list elements returned by the individual <code>FOR</code> statements will be created. </p>
<pre class="fragment">FOR u IN users
  FOR l IN locations
    RETURN { "user" : u, "location" : l }
</pre><p>In this example, there are two list iterations: an outer iteration over the list <code>users</code> plus an inner iteration over the list <code>locations</code>. The inner list is traversed as many times as there are elements in the outer list. For each iteration, the current values of <code>users</code> and <code>locations</code> are made available for further processing in the variable <code>u</code> and <code>l</code>.</p>
<h3><a class="anchor" id="AqlOperationReturn"></a>
RETURN </h3>
<p>The <code>RETURN</code> statement can (and must) be used to produce the result of a query. It is mandatory to specify a <code>RETURN</code> statement at the end of each block in a query, otherwise the query result would be undefined.</p>
<p>The general syntax for <code>return</code> is: </p>
<pre class="fragment">RETURN expression
</pre><p>The <code>expression</code> returned by <code>RETURN</code> is produced for each iteration the <code>RETURN</code> statement is placed in. That means the result of a <code>RETURN</code> statement is always a list (this includes the empty list). To return all elements from the currently iterated list without modification, the following simple form can be used: </p>
<pre class="fragment">FOR variable-name IN expression
  RETURN variable-name
</pre><p>As <code>RETURN</code> allows specifying an expression, arbitrary computations can be performed to calculate the result elements. Any of the variables valid in the scope the <code>RETURN</code> is placed in can be used for the computations.</p>
<p>Note: return will close the current scope and eliminate all local variables in it.</p>
<h3><a class="anchor" id="AqlOperationFilter"></a>
FILTER </h3>
<p>The <code>FILTER</code> statement can be used to restrict the results to elements that match an arbitrary logical condition. The general syntax is: </p>
<pre class="fragment">FILTER condition
</pre><p><code>condition</code> must be a condition that evaluates to either <code>false</code> or <code>true</code>. If the condition result is false, the current element is skipped, so it will not be processed further and not be part of the result. If the condition is true, the current element is not skipped and can be further processed. </p>
<pre class="fragment">FOR u IN users
  FILTER u.active == true &amp;&amp; u.age &lt; 39
  RETURN u
</pre><p>In the above example, all list elements from <code>users</code> will be included that have an attribute <code>active</code> with value <code>true</code> and that have an attribute <code>age</code> with a value less than <code>39</code>. All other elements from <code>users</code> will be skipped and not be included the result produced by <code>RETURN</code>.</p>
<p>It is allowed to specifiy multiple <code>FILTER</code> statements in a query, and even in the same block. If multiple <code>FILTER</code> statements are used, their results will be combined with a logical and, meaning all filter conditions must be true to include an element. </p>
<pre class="fragment">FOR u IN users
  FILTER u.active == true
  FILTER u.age &lt; 39
  RETURN u
</pre><h3><a class="anchor" id="AqlOperationSort"></a>
SORT </h3>
<p>The <code>SORT</code> statement will force a sort of the list of already produced intermediate results in the current block. <code>SORT</code> allows specifying one or multiple sort criteria and directions. The general syntax is: </p>
<pre class="fragment">SORT expression direction
</pre><p>Specifiyng the <code>direction</code> is optional. The default (implict) direction for a sort is the ascending order. To explicitly specify the sort direction, the keywords <code>ASC</code> (ascending) and <code>DESC</code> can be used. Multiple sort criteria can be separated using commas.</p>
<p>Note: when iterating over collection-based lists, the order of documents is always undefined unless an explicit sort order is defined using <code>SORT</code>. </p>
<pre class="fragment">FOR u IN users
  SORT u.lastName, u.firstName, u.id DESC
  RETURN u
</pre><h3><a class="anchor" id="AqlOperationLimit"></a>
LIMIT </h3>
<p>The <code>LIMIT</code> statement allows slicing the list of result documents using an offset and a count. It reduces the number of elements in the result to at most the specified number. Two general forms of <code>LIMIT</code> are followed: </p>
<pre class="fragment">LIMIT count
LIMIT offset, count
</pre><p>The first form allows specifying only the <code>count</code> value whereas the second form allows specifying both <code>offset</code> and <code>count</code>. The first form is identical using the second form with an <code>offset</code> value of <code>0</code>.</p>
<p>The <code>offset</code> value specifies how many elements from the result shall be discarded. It must be 0 or greater. The <code>count</code> value specifies how many elements should be at most included in the result. </p>
<pre class="fragment">FOR u IN users
  SORT u.firstName, u.lastName, u.id DESC
  LIMIT 0, 5
  RETURN u
</pre><h3><a class="anchor" id="AqlOperationLet"></a>
LET </h3>
<p>The <code>LET</code> statement can be used to assign an arbitrary value to a variable. The variable is then introduced in the scope the <code>LET</code> statement is placed in. The general syntax is: </p>
<pre class="fragment">LET variable-name = expression
</pre><p><code>LET</code> statements are mostly used to declare complex computations and to avoid repeated computations of the same value at multiple parts of a query. </p>
<pre class="fragment">FOR u IN users
  LET numRecommendations = LENGTH(u.recommendations)
  RETURN { "user" : u, "numRecommendations" : numRecommendations, "isPowerUser" : numRecommendations &gt;= 10 } 
</pre><p>In the above example, the computation of the number of recommendations is factored out using a <code>LET</code> statement, thus avoiding computing the value twice in the <code>RETURN</code> statement.</p>
<p>Another use case for <code>LET</code> is to declare a complex computation in a subquery, making the whole query more readable. </p>
<pre class="fragment">FOR u IN users
  LET friends = (
    FOR f IN friends 
      FILTER u.id == f.userId
      RETURN f
  )
  LET memberships = (
    FOR m IN memberships
      FILTER u.id == m.userId
      RETURN m
  )
  RETURN { "user" : u, "friends" : friends, "numFriends" : LENGTH(friends), "memberShips" : memberships }
</pre><h3><a class="anchor" id="AqlOperationCollect"></a>
COLLECT </h3>
<p>The <code>COLLECT</code> keyword can be used to group a list by one or multiple group criteria. The two general syntaxes for <code>COLLECT</code> are: </p>
<pre class="fragment">COLLECT variable-name = expression
COLLECT variable-name = expression INTO groups
</pre><p>The first form only groups the result by the defined group criteria defined by <code>expression</code>. In order to further process the results produced by <code>COLLECT</code>, a new variable (specified by <code>variable-name</code> is introduced. This variable contains the group value.</p>
<p>The second form does the same as the first form, but additionally introduces a variable (specified by <code>groups</code>) that contains all elements that fell into the group. Specifying the <code>INTO</code> clause is optional- </p>
<pre class="fragment">FOR u IN users
  COLLECT city = u.city INTO g
  RETURN { "city" : city, "users" : g }
</pre><p>In the above example, the list of <code>users</code> will be grouped by the attribute <code>city</code>. The result is a new list of documents, with one element per distinct <code>city</code> value. The elements from the original list (here: <code>users</code>) per city are made available in the variable <code>g</code>. This is due to the <code>INTO</code> clause.</p>
<p><code>COLLECT</code> also allows specifying multiple group criteria. Individual group criteria can be separated by commas. </p>
<pre class="fragment">FOR u IN users
  COLLECT first = u.firstName, age = u.age INTO g
  RETURN { "first" : first, "age" : age, "numUsers" : LENGTH(g) }
</pre><p>In the above example, the list of <code>users</code> is grouped by first names and ages first, and for each distinct combination of first name and age, the number of users found is returned.</p>
<p>Note: the <code>COLLECT</code> statement eliminates all local variables in the current scope. After <code>COLLECT</code> only the variables introduced by <code>COLLECT</code> itself are available.</p>
<h2><a class="anchor" id="AqlAdvanced"></a>
Advanced features </h2>
<h3><a class="anchor" id="AqlSubqueries"></a>
Subqueries </h3>
<p>Whereever an expression is allowed in AQL, a subquery can be placed. A subquery is a query part that can introduce its own local variables without affecting variables and values in its outer scope(s).</p>
<p>It is required that subqueries be put inside parentheses <code>(</code> and <code>)</code> to explicitly mark their start and end points: </p>
<pre class="fragment">FOR u IN users
  LET recommendations = ( 
    FOR r IN recommendations
      FILTER u.id == r.userId
      SORT u.rank DESC
      LIMIT 10
      RETURN r
  )
  RETURN { "user" : u, "recommendations" : recommendations }

FOR u IN users
  COLLECT city = u.city INTO g
  RETURN { "city" : city, "numUsers" : LENGTH(g), "maxRating": MAX(
    FOR r IN g 
      RETURN r.user.rating
  ) }
</pre><p>Subqueries might also include other subqueries themselves.</p>
<h3><a class="anchor" id="AqlExpansion"></a>
Variable expansion </h3>
<p>In order to access a named attribute from all elements in a list easily, AQL offers the shortcut operator <code>[*]</code> for variable expansion.</p>
<p>Using the <code>[*]</code> operator with a variable will iterate over all elements in the variable thus allowing to access a particular attribute of each element. It is required that the expanded variable is a list. The result of the <code>[*]</code> operator is again a list. </p>
<pre class="fragment">FOR u IN users
  RETURN { "user" : u, "friendNames" : u.friends[*].name }
</pre><p>In the above example, the attribute <code>name</code> is accessed for each element in the list <code>u.friends</code>. The result is a flat list of friend names, made available as the attribute <code>friendNames</code>. </p>
</div></div><!-- contents -->
</div>


	  </div><!-- .entry-content -->
	</div><!-- #post-## -->


      <div id="comments">


  <p class="nocomments">Comments are closed.</p>



</div><!-- #comments -->


      </div><!-- #content -->
    </div><!-- #container -->

  <div style="clear:both;"></div>
  </div><!-- #main -->



</div><!-- #wrapper -->
</div><!-- #surrounding -->


  <div id="footer" role="contentinfo">
    <div id="colophon">




      <div id="footer-widget-area" role="complementary">

	<div id="first" class="widget-area">
	  <ul class="xoxo">
		<li id="recent-posts-4" class="widget-container widget_recent_entries">	  <h3 class="widget-title">Recent Posts</h3>	<ul>
	  <li>
	<a href="http://www.arangodb.org/2013/05/22/replication-and-sharding-in-arangodb" title="Our plans on replication and sharding in ArangoDB">Our plans on replication and sharding in ArangoDB</a>
	    </li>
	  <li>
	<a href="http://www.arangodb.org/2013/05/14/ideas-and-facts-from-scotland-js-in-edinburgh" title="Ideas and Facts from scotland.js in Edinburgh">Ideas and Facts from scotland.js in Edinburgh</a>
	    </li>
	  <li>
	<a href="http://www.arangodb.org/2013/05/12/arangodb-1-3-0-released" title="ArangoDB 1.3.0 released">ArangoDB 1.3.0 released</a>
	    </li>
	  <li>
	<a href="http://www.arangodb.org/2013/05/06/foxx-screencast-part-2" title="Foxx Screencast: Part 2">Foxx Screencast: Part 2</a>
	    </li>
	</ul>
    </li><li id="text-5" class="widget-container widget_text"><h3 class="widget-title">Documentation</h3>     <div class="textwidget"><ul>
  <li><a href="/quickstart">First step tutorial</a></li>
  <li><a href="/manuals">Manual/documentation (HTML/PDF)</a></li>
  <li><a href="/manuals/arangodb_1.0_shell_reference_card.pdf">ArangoDB Shell Reference Card (HTML/PDF)</a></li>
  <li><a href="/try">Try ArangoDB online</a></li>
  <li><a href="/api">API clients & 3rd party libs</a></li>
        <li><a href="/logos">ArangoDB artwork/logos</a></li>
</ul>
</div>
    </li><li id="text-7" class="widget-container widget_text"><h3 class="widget-title">Social Links</h3>      <div class="textwidget"><ul>
  <li><a href="https://twitter.com/arangodb">ArangoDB on Twitter</a></li>
  <li><a href="https://groups.google.com/group/arangodb">ArangoDB Google Group</a></li>
  <li><a href="http://stackoverflow.com/questions/tagged/arangodb">ArangoDB questions on StackOverflow</a></li>
  <li><a href="https://github.com/triagens/arangodb/issues?state=open">Issue Tracker at Github</a></li>
</ul></div>
    </li><li id="text-6" class="widget-container widget_text"><h3 class="widget-title">Roadmap</h3>	<div class="textwidget"><ul>
  <li><a href="/roadmap/#v1.4">Backlog for Version 1.4</a></li>
  <li><a href="/roadmap/#v1.x">Backlog for Version 1.x</a></li>
</ul></div>
    </li>	  </ul>
	</div><!-- #first .widget-area -->




      </div><!-- #footer-widget-area -->


<!-- #site-generator -->

    </div><!-- #colophon -->

        <div class="copy">
            Copyright 2013 ArangoDB | <a href="/imprint">Imprint</a>
        </div>

  </div><!-- #footer -->

</body>
</html>