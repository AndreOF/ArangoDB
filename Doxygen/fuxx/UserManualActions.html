<!DOCTYPE html>
<html lang="en-US" prefix="og: http://ogp.me/ns#">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />


<link rel="shortcut icon" type="image/x-icon" href="http://www.arangodb.org/wp-content/themes/triagens/images/favicon.ico">

<link rel="profile" href="http://gmpg.org/xfn/11" />
<link rel="stylesheet" type="text/css" media="all" href="http://www.arangodb.org/wp-content/themes/triagens-child/style.css" />
<link rel="pingback" href="" />


<!-- This site is optimized with the Yoast WordPress SEO plugin v1.4.4 - http://yoast.com/wordpress/seo/ -->
<title>ArangoDB Manual Pages - ArangoDB</title>
<meta name="description" content="ArangoDB Manual Pages"/>
<link rel="canonical" href="http://www.arangodb.org/manualredirector" />
<meta property='og:locale' content='en_US'/>
<meta property='og:title' content='ArangoDB Manual Pages - ArangoDB'/>
<meta property='og:description' content='ArangoDB Manual Pages'/>
<meta property='og:url' content='http://www.arangodb.org/manualredirector'/>
<meta property='og:site_name' content='ArangoDB'/>
<meta property='og:type' content='article'/>
<!-- / Yoast WordPress SEO plugin. -->

<link rel="alternate" type="application/rss+xml" title="ArangoDB &raquo; Feed" href="http://www.arangodb.org/feed" />
<link rel="alternate" type="application/rss+xml" title="ArangoDB &raquo; Comments Feed" href="http://www.arangodb.org/comments/feed" />
<link rel='stylesheet' id='wordpress-popular-posts-css'  href='http://www.arangodb.org/wp-content/plugins/wordpress-popular-posts/style/wpp.css?ver=3.5.1' type='text/css' media='all' />
<link rel='stylesheet' id='wp-syntax-css-css'  href='http://www.arangodb.org/wp-content/plugins/wp-syntax/css/wp-syntax.css?ver=1.0' type='text/css' media='all' />
<script type='text/javascript' src='http://www.arangodb.org/wp-includes/js/jquery/jquery.js?ver=1.8.3'></script>
<script type='text/javascript' src='http://www.arangodb.org/wp-includes/js/comment-reply.min.js?ver=3.5.1'></script>

    <style type="text/css">
    body {
    margin-top: -28px;
    padding-bottom: 28px;
    }
    body.admin-bar #wphead {
       padding-top: 0;
    }
    body.admin-bar #footer {
       padding-bottom: 28px;
    }
<link type="text/css" media="screen" rel="stylesheet" href="http://www.arangodb.org/wp-content/plugins/tweet-blender/css/tweets.css" />

    <style media="print" type="text/css">
      div.faq_answer {display: block!important;}
      p.faq_nav {display: none;}
    </style>


</head>

<body class="page page-id-1410 page-template page-template-onecolumn-page-php">

    <div id="access" role="navigation">
        <div id="nav">
            <a href="http://www.arangodb.org/" title="ArangoDB" id="branding"><img src="/wp-content/themes/triagens/images/logo_arangob_white.gif" width="154" height="34" alt="ArangoDB"></a>
            <div class="menu-header"><ul id="menu-home" class="menu"><li id="menu-item-184" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-184"><a href="http://www.arangodb.org/">Home</a></li>
<li id="menu-item-1345" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1345"><a href="http://www.arangodb.org/try">Try it out</a></li>
<li id="menu-item-279" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-279"><a href="http://www.arangodb.org/documentation">Documentation</a></li>
<li id="menu-item-95" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-95"><a href="http://www.arangodb.org/roadmap">Roadmap</a></li>
<li id="menu-item-71" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-71"><a href="http://www.arangodb.org/download">Downloads</a></li>
<li id="menu-item-1299" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-1299"><a href="http://www.arangodb.org/api">Drivers</a></li>
<li id="menu-item-156" class="menu-item menu-item-type-post_type menu-item-object-page menu-item-156"><a href="http://www.arangodb.org/blog">Blog</a></li>
</ul></div>            <div class="clear_both"></div>
        </div>
    </div><!-- #access -->

  <div id="surrounding">

    <div id="wrapper" class="hfeed">
	<div id="main">

    <div id="fullsize" class="one-column">
      <div id="content" role="main">



            <div id="post-1410" class="post-1410 page type-page status-publish hentry">
                    <h2 class="entry-title">ArangoDB Manual Pages</h2>

	  <div class="entry-content">

<link id="arangodb.css" type="text/css" href="arangodb.css" rel="stylesheet">
</div>
<div id="manual_search">
<form action="/" id="searchform" method="get" role="search">
  <div><label for="s" class="screen-reader-text">Search for:</label>
    <input type="text" id="s" name="s" value="" />
    <input type="submit" value="Search" id="searchsubmit" />
  </div>
</form>
</div>
<div class="clear_both"></div>
<hr />
<div class="arangodb">
<div>
<!-- Generated by Doxygen 1.8.2 -->
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">ArangoDB's Actions </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"> <div class="navigate"><a href="AqlExamples.html">prev</a> | <a href="UserManual.html">home</a> | <a href="UserManualFoxx.html">next</a></div>  <div class="toc"><ul>
<li><a class="el" href="UserManualActions.html">ArangoDB's Actions</a><ul>
<li><a class="el" href="UserManualActions.html#UserManualActionsIntro">Introduction to User Actions</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsHelloWorld">A Hello World Example</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsMatches">Matching a URL</a><ul>
<li><a class="el" href="UserManualActions.html#UserManualActionsMatchesExact">Exact Match</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsMatchesPrefix">Prefix Match</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsMatchesParameterized">Parameterized Match</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsMatchesConstraint">Constraint Match</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsMatchesOptional">Optional Match</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsMatchesMethod">Method Restriction</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsMatching">More on Matching</a></li>
</ul>
</li>
<li><a class="el" href="UserManualActions.html#UserManualActionsHelloJson">A Hello World Example for JSON</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsContent">Delivering Content</a><ul>
<li><a class="el" href="UserManualActions.html#UserManualActionsContentStatic">Static Content</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsContentAction">A Simple Action</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsContentController">Action Controller</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsContentPrefix">Prefix Action Controller</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsFunctionAction">Function Action</a></li>
</ul>
</li>
<li><a class="el" href="UserManualActions.html#UserManualActionsReqRes">Requests and Responses</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsModify">Modifying Request and Response</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsHandlers">Writing dynamic action handlers</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsCache">A Word about Caching</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsAdvanced">Advanced Usages</a><ul>
<li><a class="el" href="UserManualActions.html#UserManualActionsAdvancedRedirects">Redirects</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsAdvancedBundles">Routing Bundles</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsAdvancedMiddleware">Writing Middleware</a></li>
</ul>
</li>
<li><a class="el" href="UserManualActions.html#UserManualActionsApplicationDeployment">Application Deployment</a><ul>
<li><a class="el" href="UserManualActions.html#UserManualActionsDeployingStaticPages">Deploying Static Pages</a></li>
<li><a class="el" href="UserManualActions.html#UserManualActionsDeployingModules">Deploying Modules</a> </li>
</ul>
</li>
</ul>
</li>
</ul>
  </div> <h2><a class="anchor" id="UserManualActionsIntro"></a>
Introduction to User Actions</h2>
<p>In some ways the communication layer of the ArangoDB server behaves like a Web server. Unlike a Web server, it normally responds to HTTP requests by delivering JSON objects. Remember, documents in the database are just JSON objects. So, most of the time the HTTP response will contain a JSON document from the database as body. You can extract the documents stored in the database using HTTP <code>GET</code>. You can store documents using HTTP <code>POST</code>.</p>
<p>However, there is something more. You can write small sniplets - so called actions - to extend the database. The idea of actions is that sometimes it is better to store parts of the business logic within AnrangoDB.</p>
<p>The simplest example is the age of a person. Assume you store information about people in your database. It is an anti-pattern to store the age, because it changes every now and then. Therefore, you normally store the birthday and let the client decide what to do with it. However, if you have many different clients, it might be easier to enrich the person document with the age using actions once on the server side.</p>
<p>Or, for instance, if you want to apply some statistics to large data-sets and you cannot easily express this as query. You can define a action instead of transferring the whole data to the client and do the computation on the client.</p>
<p>Actions are also useful if you want to restrict and filter data according to some complex permission system.</p>
<p>The ArangoDB server can deliver all kinds of information, JSON being only one possible format. You can also generate HTML or images. However, a Web server is normally better suited for the task as it also implements various caching strategies, language selection, compression and so on. Having said that, there are still situations where it might be suitable to use the ArangoDB to deliver HTML pages - static or dynamic. A simple example is the built-in administration interface. You can access it using any modern browser and there is no need for a separate Apache or IIS.</p>
<p>The following sections will explain actions within ArangoDB and show how to define them. The examples start with delivering static HTML pages - even if this is not the primary use-case for actions. The later sections will then show you how to code some pieces of your business logic and return JSON objects.</p>
<p>The interface is loosely modelled after the JavaScript classes for HTTP request and responses found in node.js and the middleware/routing aspects of connect.js and express.js.</p>
<p>Note that unlike node.js, ArangoDB is multi-threaded and there is no easy way to share state between queries inside the JavaScript engine. If such state information is required, you need to use the database itself.</p>
<h2><a class="anchor" id="UserManualActionsHelloWorld"></a>
A Hello World Example</h2>
<p>The client API or browser sends a HTTP request to the ArangoDB server and the server returns a HTTP response to the client. A HTTP request consists of a method, normally <code>GET</code> or <code>POST</code> when using a browser, and a request path like <code>/hello/world</code>. For a real Web server there are a zillion of other thing to consider, we will ignore this for the moment. The HTTP response contains a content type, describing how to interpret the returned data, and the data itself.</p>
<p>In the following example, we want to define an action in ArangoDB, so that the server returns the HTML document </p>
<pre class="fragment">&lt;html&gt;
 &lt;body&gt;
  Hello World
 &lt;/body&gt;
&lt;/html&gt;
</pre><p>if asked <code>GET /hello/world</code>.</p>
<p>The server needs to know what function to call or what document to deliver if it receives a request. This is called routing. All the routing information of ArangoDB is stored in a collection <code>_routing</code>. Each entry in this collections describes how to deal with a particular request path.</p>
<p>For the above example, add the following document to the_routing} collection: </p>
<pre class="fragment">arangosh&gt; db._routing.save({ 
........&gt;   url: { match: "/hello/world" },
........&gt;   content: { 
........&gt;     contentType: "text/html", 
........&gt;     body: "&lt;html&gt;&lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;" }});
</pre><p>In order to activate the new routing, you must either restart the server or call the internal reload function. </p>
<pre class="fragment">arangosh&gt; require("internal").reloadRouting()
</pre><p>Now use the browser and access </p>
<pre class="fragment">http://localhost:8529/hello/world
</pre><p>You should see the <code>Hello World</code> in our browser.</p>
<h2><a class="anchor" id="UserManualActionsMatches"></a>
Matching a URL</h2>
<p>There are a lot of options for the <code>url</code> attribute. If you define different routing for the same path, then the following simple rule is applied in order to determine which match wins: If there are two matches, then the more specific wins. I. e, if there is a wildcard match and an exact match, the exact match is prefered. If there is a short and a long match, the longer match wins.</p>
<h3><a class="anchor" id="UserManualActionsMatchesExact"></a>
Exact Match</h3>
<p>If the definition is </p>
<pre class="fragment">{ url: { match: "/hello/world" } }
</pre><p>then the match must be exact. Only the request for <code>/hello/world</code> will match, everything else, e. g. <code>/hello/world/my</code> or <code>/hello/world2</code>, will not match.</p>
<p>The following definition is a short-cut for an exact match. </p>
<pre class="fragment">{ url: "/hello/world" }
</pre><p>Please note that while the two definitions will result in the same URL matching, there is a subtle difference between them:</p>
<p>The former definition (defining <code>url</code> as an object with a <code>match</code> attribute) will result in the URL being accessible via all supported HTTP methods (e.g. <code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>DELETE</code>, ...), whereas the latter definition (providing a string <code>url</code> attribute) will result in the URL being accessible via HTTP <code>GET</code> and HTTP <code>HEAD</code> only, with all other HTTP methods being disabled. Calling a URL with an unsupported or disabled HTTP method will result in an HTTP 501 error.</p>
<h3><a class="anchor" id="UserManualActionsMatchesPrefix"></a>
Prefix Match</h3>
<p>If the definition is </p>
<pre class="fragment">{ url: { match: "/hello/world/*" } }
</pre><p>then the match can be a prefix match. The requests for <code>/hello/world</code>, <code>/hello/world/my</code>, and <code>/hello/world/how/are/you</code> will all match. However <code>/hello/world2</code> does not match. Prefix matches within a URL part, i. e. <code>/hello/world*</code>, are not allowed. The wildcard must occur at the end, i. e. </p>
<pre class="fragment">/hello/*/world 
</pre><p>is also disallowed.</p>
<p>If you define two routes </p>
<pre class="fragment">{ url: { match: "/hello/world/*" } }
{ url: { match: "/hello/world/emil" } }
</pre><p>then the second route will be used for <code>/hello/world/emil</code> because it is more specific.</p>
<h3><a class="anchor" id="UserManualActionsMatchesParameterized"></a>
Parameterized Match</h3>
<p>A parameterized match is similar to a prefix match, but the parameters are also allowed inside the URL path.</p>
<p>If the definition is </p>
<pre class="fragment">{ url: { match: "/hello/:name/world" } }
</pre><p>then the URL must have three parts, the first part being <code>hello</code> and the third part <code>world</code>. For example, <code>/hello/emil/world</code> will match, while <code>/hello/emil/meyer/world</code> will not.</p>
<h3><a class="anchor" id="UserManualActionsMatchesConstraint"></a>
Constraint Match</h3>
<p>A constraint match is similar to a parameterized match, but the parameters can carry constraints.</p>
<p>If the definition is </p>
<pre class="fragment">{ url: { match: "/hello/:name/world", constraint: { name: "/[a-z]+/" } }
</pre><p>then the URL must have three parts, the first part being <code>hello</code> and the third part <code>world</code>. The second part must be all lowercase.</p>
<p>It is possible to use more then one constraint for the same URL part. </p>
<pre class="fragment">{ url: { match: "/hello/:name|:id/world",
         constraint: { name: "/[a-z]+/", id: "/[0-9]+/" } }
</pre><h3><a class="anchor" id="UserManualActionsMatchesOptional"></a>
Optional Match</h3>
<p>An optional match is similar to a parameterized match, but the last parameter is optional.</p>
<p>If the definition is </p>
<pre class="fragment">{ url: { match: "/hello/:name?", constraint: { name: "/[a-z]+/" } }
</pre><p>then the URL <code>/hello</code> and <code>/hello/emil</code> will match.</p>
<p>If the definitions are </p>
<pre class="fragment">{ url: { match: "/hello/world" } }
{ url: { match: "/hello/:name", constraint: { name: "/[a-z]+/" } }
{ url: { match: "/hello/*" } }
</pre><p>then the URL <code>/hello/world</code> will be matched by the first route, because it is the most specific. The URL <code>/hello/you</code> will be matched by the second route, because it is more specific than the prefix match.</p>
<h3><a class="anchor" id="UserManualActionsMatchesMethod"></a>
Method Restriction</h3>
<p>You can restrict the match to specific HTTP methods.</p>
<p>If the definition is </p>
<pre class="fragment">{ url: { match: "/hello/world", methods: [ "post", "put" ] }
</pre><p>then only HTTP <code>POST</code> and <code>PUT</code> requests will match. Calling with a different HTTP method will result in an HTTP 501 error.</p>
<p>Please note that if <code>url</code> is defined as a simple string, then only the HTTP methods <code>GET</code> and <code>HEAD</code> will be allowed, an all other methods will be disabled: </p>
<pre class="fragment">{ url: "/hello/world" }
</pre><h3><a class="anchor" id="UserManualActionsMatching"></a>
More on Matching</h3>
<p>Remember that the more specific match wins.</p>
<ul>
<li>A match without parameter or wildcard is more specific than a match with parameters or wildcard.</li>
<li>A match with parameter is more specific than a match with a wildcard.</li>
<li>If there is more than one parameter, specificity is applied from left to right.</li>
</ul>
<p>Consider the following definitions </p>
<pre class="fragment">(1) { url: { match: "/hello/world" } }
(2) { url: { match: "/hello/:name", constraint: { name: "/[a-z]+/" } }
(3) { url: { match: "/:something/world" }
(4) { url: { match: "/hello/*" } }
</pre><p>Then</p>
<ul>
<li><code>/hello/world</code> is match by (1)</li>
<li><code>/hello/emil</code> is match by (2)</li>
<li><code>/your/world</code> is match by (3)</li>
<li><code>/hello/you</code> is match by (4)</li>
</ul>
<p>You can write the following document into the <code>_routing</code> collection to test the above examples. </p>
<pre class="fragment">{
  routes: [
    { url: { match: "/hello/world" }, content: "route 1" },
    { url: { match: "/hello/:name|:id", constraint: { name: "/[a-z]+/", id: "/[0-9]+/" } }, content: "route 2" },
    { url: { match: "/:something/world" }, content: "route 3" },
    { url: { match: "/hello/*" }, content: "route 4" },
  ]
}
</pre><h2><a class="anchor" id="UserManualActionsHelloJson"></a>
A Hello World Example for JSON</h2>
<p>If you change the example slightly, then a JSON object will be delivered. </p>
<pre class="fragment">arangosh&gt; db._routing.save({ 
........&gt;   url: "/hello/json", 
........&gt;   content: { 
........&gt;     contentType: "application/json", 
........&gt;     body: "{ \"hello\" : \"world\" }" }});
arangosh&gt; require("internal").reloadRouting()
</pre><p>Again check with your browser </p>
<pre class="fragment">http://localhost:8529/hello/json
</pre><p>Depending on your browser and installed add-ons you will either see the JSON object or a download dialog. If your browser wants to open an external application to display the JSON object, you can change the <code>contentType</code> to <code>"text/plain"</code> for the example. This makes it easier to check the example using a browser. Or use <code>curl</code> to access the server. </p>
<pre class="fragment">bash&gt; curl "http://127.0.0.1:8529/hello/json" &amp;&amp; echo
{ "hello" : "world" }
</pre><h2><a class="anchor" id="UserManualActionsContent"></a>
Delivering Content</h2>
<p>There are a lot of different ways on how to deliver content. We have already seen the simplest one, where static content is delivered. The fun, however, starts when delivering dynamic content.</p>
<h3><a class="anchor" id="UserManualActionsContentStatic"></a>
Static Content</h3>
<p>You can specify a body and a content-type. </p>
<pre class="fragment">{ content: {
    contentType: "text/html",
    body: "&lt;html&gt;&lt;body&gt;Hello World&lt;/body&gt;&lt;/html&gt;"
  }
}
</pre><p>If the content type is <code>text/plain</code> then you can use the short-cut </p>
<pre class="fragment">{ content: "Hello World" }
</pre><h2><a class="anchor" id="UserManualActionsContentAction"></a>
A Simple Action</h2>
<p>The simplest dynamic action is: </p>
<pre class="fragment">{ action: { do: "org/arangodb/actions/echoRequest" } }
</pre><p>It is not advisable to store functions directly in the routing table. It is better to call functions defined in modules. In the above example the function can be accessed from JavaScript as: </p>
<pre class="fragment">require("org/arangodb/actions").echoRequest
</pre><p>The function <code>echoRequest</code> is pre-defined. It takes the request objects and echos it in the response.</p>
<p>The signature of such a function must be </p>
<pre class="fragment">function (req, res, options, next)
</pre><p>For example </p>
<pre class="fragment">arangosh&gt; db._routing.save({ 
........&gt;   url: "/hello/echo",
........&gt;   action: { do: "org/arangodb/actions/echoRequest" } });
</pre><p>Reload the routing and check </p>
<pre class="fragment">http://127.0.0.1:8529/hello/echo
</pre><p>You should see something like </p>
<pre class="fragment">{
    "request": {
        "path": "/hello/echo",
        "headers": {
            "accept-encoding": "gzip, deflate",
            "accept-language": "de-de,de;q=0.8,en-us;q=0.5,en;q=0.3",
            "connection": "keep-alive",
            "content-length": "0",
            "host": "localhost:8529",
            "user-agent": "Mozilla/5.0 (X11; Linux x86_64; rv:15.0) Gecko/20100101 Firefox/15.0"
        },
        "requestType": "GET",
        "parameters": { }
    },
    "options": { }
}
</pre><p>The request might contain <code>path</code>, <code>prefix</code>, <code>suffix</code>, and <code>urlParameters</code> attributes. <code>path</code> is the complete path as supplied by the user and always available. If a prefix was matched, then this prefix is stored in the attribute <code>prefix</code> and the remaining URL parts are stored as an array in <code>suffix</code>. If one or more parameters were matched, then the parameter values are stored in <code>urlParameters</code>.</p>
<p>For example, if the url description is </p>
<pre class="fragment">{ url: { match: "/hello/:name/:action" } }
</pre><p>and you request the path <code>/hello/emil/jump</code>, then the request object will contain the following attribute </p>
<pre class="fragment">urlParameters: { name: "emil", action: "jump" } }
</pre><h3><a class="anchor" id="UserManualActionsContentController"></a>
Action Controller</h3>
<p>As an alternative to the simple action, you can use controllers. A controller is a module, defines the function <code>get</code>, <code>put</code>, <code>post</code>, <code>delete</code>, <code>head</code>, <code>patch</code>. If a request of the corresponding type is matched, the function will be called.</p>
<p>For example </p>
<pre class="fragment">arangosh&gt; db._routing.save({ 
........&gt;   url: "/hello/echo",
........&gt;   action: { controller: "org/arangodb/actions/echoController" } });
</pre><h3><a class="anchor" id="UserManualActionsContentPrefix"></a>
Prefix Action Controller</h3>
<p>The controller is selected when the definition is read. There is a more flexible, but slower and maybe insecure variant, the prefix controller.</p>
<p>Assume that the url is a prefix match </p>
<pre class="fragment">{ url: { match: /hello/*" } }
</pre><p>You can use </p>
<pre class="fragment">{ action: { prefixController: "org/arangodb/actions" } }
</pre><p>to define a prefix controller. If the URL <code>/hello/echoController</code> is given, then the module <code>org/arangodb/actions/echoController</code> is used.</p>
<p>If you use a prefix controller, you should make certain that no unwanted actions are available under the prefix.</p>
<p>The definition </p>
<pre class="fragment">{ action: "org/arangodb/actions" }
</pre><p>is a short-cut for a prefix controller definition.</p>
<h3><a class="anchor" id="UserManualActionsFunctionAction"></a>
Function Action</h3>
<p>You can also store a function directly in the routing table.</p>
<p>For example </p>
<pre class="fragment">arangosh&gt; db._routing.save({ 
........&gt;   url: "/hello/echo",
........&gt;   action: { callback: "function(req,res) {res.statusCode=200; res.body='Hello'}" } });
</pre><h2><a class="anchor" id="UserManualActionsReqRes"></a>
Requests and Responses</h2>
<p>The controller must define handler functions which take a request object and fill the response object.</p>
<p>A very simple example is the function <code>echoRequest</code> defined in the module <code>org/arangodb/actions</code>. </p>
<pre class="fragment">function (req, res, options, next) {
  var result;

  result = { request: req, options: options };

  res.responseCode = exports.HTTP_OK;
  res.contentType = "application/json";
  res.body = JSON.stringify(result);
}
</pre><p>Install it as </p>
<pre class="fragment">arangosh&gt; db._routing.save({ 
........&gt;   url: "/echo",
........&gt;   action: { do: "org/arangodb/actions/echoRequest" } });
</pre><p>Reload the routing and check </p>
<pre class="fragment">http://127.0.0.1:8529/hello/echo
</pre><p>You should see something like </p>
<pre class="fragment">{
    "request": {
        "prefix": "/hello/echo",
        "suffix": [
            "hello",
            "echo"
        ],
        "path": "/hello/echo",
        "headers": {
            "accept-encoding": "gzip, deflate",
            "accept-language": "de-de,de;q=0.8,en-us;q=0.5,en;q=0.3",
            "connection": "keep-alive",
            "content-length": "0",
            "host": "localhost:8529",
            "user-agent": "Mozilla/5.0 (X11; Linux x86_64; rv:15.0) Gecko/20100101 Firefox/15.0"
        },
        "requestType": "GET",
        "parameters": { }
    },
    "options": { }
}
</pre><p>You may also pass options to the called function: </p>
<pre class="fragment">arangosh&gt; db._routing.save({ 
........&gt;   url: "/echo",
........&gt;   action: {
........&gt;     do: "org/arangodb/actions/echoRequest",
........&gt;     options: { "Hello": "World" } } });
</pre><p>You should now see the options in the result. </p>
<pre class="fragment">{
    "request": {
        ...
    },
    "options": {
        "Hello": "World"
    }
}
</pre><h2><a class="anchor" id="UserManualActionsModify"></a>
Modifying Request and Response</h2>
<p>As we've seen in the previous examples, actions get called with the request and response objects (named <code>req</code> and <code>res</code> in the examples) passed as parameters to their handler functions.</p>
<p>The <code>req</code> object contains the incoming HTTP request, which might or might not have been modified by a previous action (if actions were chained).</p>
<p>A handler can modify the request object in place if desired. This might be useful when writing middleware (see below) that is used to intercept incoming requests, modify them and pass them to the actual handlers.</p>
<p>While modifying the request object might not be that relevant for non-middleware actions, modifying the response object definitely is. Modifying the response object is an action's only way to return data to the caller of the action.</p>
<p>We've already seen how to set the HTTP status code, the content type, and the result body. The <code>res</code> object has the following properties for these:</p>
<ul>
<li>contentType: MIME type of the body as defined in the HTTP standard (e.g. <code>text/html</code>, <code>text/plain</code>, <code>application/json</code>, ...)</li>
<li>responsecode: the HTTP status code of the response as defined in the HTTP standard. Common values for actions that succeed are <code>200</code> or <code>201</code>. Please refer to the HTTP standard for more information.</li>
<li>body: the actual response data</li>
</ul>
<p>To set or modify arbitrary headers of the response object, the <code>headers</code> property can be used. For example, to add a user-defined header to the response, the following code will do: </p>
<pre class="fragment">res.headers = res.headers || { }; // headers might or might not be present
res.headers['X-Test'] = 'someValue'; // set header X-Test to "someValue"
</pre><p>This will set the additional HTTP header <code>X-Test</code> to value <code>someValue</code>. Other headers can be set as well. Note that ArangoDB might change the case of the header names to lower case when assembling the overall response that is sent to the caller.</p>
<p>It is not necessary to explicitly set a <code>Content-Length</code> header for the response as ArangoDB will calculate the content length automatically and add this header itself. ArangoDB might also add a <code>Connection</code> header itself to handle HTTP keep-alive.</p>
<p>ArangoDB also supports automatic transformation of the body data to another format. Currently, the only supported transformations are base64-encoding and base64-decoding. Using the transformations, an action can create a base64 encoded body and still let ArangoDB send the non-encoded version, for example: </p>
<pre class="fragment">res.body = 'VGhpcyBpcyBhIHRlc3Q=';
res.transformations = res.transformations || [ ]; // initialise
res.transformations.push('base64decode'); // will base64 decode the response body
</pre><p>When ArangoDB processes the response, it will base64-decode what's in <code>res.body</code> and set the HTTP header <code>Content-Encoding: binary</code>. The opposite can be achieved with the <code>base64encode</code> transformation: ArangoDB will then automatically base64-encode the body and set a <code>Content-Encoding: base64</code> HTTP header.</p>
<h2><a class="anchor" id="UserManualActionsHandlers"></a>
Writing dynamic action handlers</h2>
<p>To write your own dynamic action handlers, you must put them into modules.</p>
<p>Modules are a means of organising action handlers and making them loadable under specific names.</p>
<p>To start, we'll define a simple action handler in a module <code>/own/test</code>: </p>
<pre class="fragment">arangosh&gt; db._modules.save({ 
........&gt;   path: "/own/test",
........&gt;   content: "exports.do = function(req, res, options, next) { res.body = 'test'; res.responseCode = 200; res.contentType = 'text/html'; };",
........&gt;   autoload: true });
</pre><p>This does nothing but register a do action handler in a module <code>/own/test</code>. The action handler is not yet callable, but must be mapped to a route first. To map the action to the route <code>/ourtest</code>, execute the following command: </p>
<pre class="fragment">arangosh&gt; db._routing.save({ 
........&gt;   url: "/ourtest",
........&gt;   action: { controller: "/own/test" } }); 
</pre><p>In order to see the module in action, you must either restart the server or call the internal reload function. </p>
<pre class="fragment">arangosh&gt; require("internal").reloadRouting()
</pre><p>Now use the browser and access </p>
<pre class="fragment">http://localhost:8529/ourtest
</pre><p>You will see that the module's do function has been executed.</p>
<h2><a class="anchor" id="UserManualActionsCache"></a>
A Word about Caching</h2>
<p>Sometimes it might seem that your change do not take effect. In this case the culprit could be one of the caches. With dynamic actions there are two caches involved:</p>
<h3>The Routing Cache</h3>
<p>The routing cache stores the routing information computed from the <code>_routing</code> collection. Whenever you change this collection manually, you need to call </p>
<pre class="fragment">arangosh&gt; require("internal").reloadRouting()
</pre><p>in order to rebuild the cache.</p>
<h3>The Modules Cache</h3>
<p>If you use a dynamic action and this action is stored in module, then the module functions are also stored in a cache in order to avoid parsing the JavaScript code again and again.</p>
<p>Whenever you change the <code>modules</code> collections manually, you need to call </p>
<pre class="fragment">arangosh&gt; require("internal").flushServerModules()
</pre><p>in order to rebuild the cache.</p>
<h3>Flush Order</h3>
<p>If you define a dynamic routing and the controller, then you need to flush the caches in a particular order. In order to build the routes, the module information must be known. Therefore, you need to flush the modules caches first. </p>
<pre class="fragment">arangosh&gt; require("internal").flushServerModules()
arangosh&gt; require("internal").reloadRouting()
</pre><h2><a class="anchor" id="UserManualActionsAdvanced"></a>
Advanced Usages</h2>
<p>For detailed information see the reference manual.</p>
<h3><a class="anchor" id="UserManualActionsAdvancedRedirects"></a>
Redirects</h3>
<p>Use the following for a permanent redirect: </p>
<pre class="fragment">arangosh&gt; db._routing.save({ 
........&gt;   url: "/",
........&gt;   action: {
........&gt;     do: "org/arangodb/actions/redirectRequest", 
........&gt;     options: { 
........&gt;       permanently: true,
........&gt;       destination: "http://somewhere.else/" } } });
</pre><h3><a class="anchor" id="UserManualActionsAdvancedBundles"></a>
Routing Bundles</h3>
<p>Instead of adding all routes for package separately, you can specify a bundle. </p>
<pre class="fragment">{
  routes: [ 
    { url: "/url1", content: "..." },
    { url: "/url2", content: "..." },
    { url: "/url3", content: "..." },
    ... 
  ]
}
</pre><p>The advantage is, that you can put all your routes into one document and use a common prefix. </p>
<pre class="fragment">{
  urlPrefix: "/test",

  routes: [ 
    { url: "/url1", content: "..." },
    { url: "/url2", content: "..." },
    { url: "/url3", content: "..." },
    ... 
  ]
}
</pre><p>will define the URL <code>/test/url1</code>, <code>/test/url2</code>, and <code>/test/url3</code>.</p>
<h3><a class="anchor" id="UserManualActionsAdvancedMiddleware"></a>
Writing Middleware</h3>
<p>Assume, you want to log every request. In this case you can easily define an action for the whole url-space <code>/</code>. This action simply logs the requests, calls the next in line, and logs the response. </p>
<pre class="fragment">exports.logRequest = function (req, res, options, next) {
  console.log("received request: %s", JSON.stringify(req));
  next();
  console.log("produced response: %s", JSON.stringify(res));
};
</pre><p>This function is available as <code>org/arangodb/actions/logRequest</code>. You need to tell ArangoDB that it is should use a prefix match and that the shortest match should win in this case: </p>
<pre class="fragment">arangosh&gt; db._routing.save({ 
........&gt;   middleware: [
........&gt;     { url: { match: "/*" }, action: { do: "org/arangodb/actions/logRequest" } }
........&gt;   ]
........&gt; });
</pre><h2><a class="anchor" id="UserManualActionsApplicationDeployment"></a>
Application Deployment</h2>
<p>Using single routes or <a class="el" href="UserManualActions.html#UserManualActionsAdvancedBundles">bundles</a> can be become a bit messy in large applications. Therefore a deployment tool exists inside <em>arangosh</em> to simplify the task. This tool was inspired by the ArangoDB deployment tool <code><a href="https://github.com/kaerus/arangodep">https://github.com/kaerus/arangodep</a></code> written in node.js by kaerus.</p>
<p>An application is a bunch of routes, static pages stored in collections, and small scriptlets stored modules.</p>
<p>In order to create an application, chose a suitable name, e. g. reverse domain name plus the application name and call <code>createApp</code>: </p>
<pre class="fragment">arangosh&gt; var deploy = require("org/arangodb/deploy");
arangosh&gt; var app = deploy.createApp("org.example.simple");
</pre><p>Normally content will either be stored in collections or dynamically calculated. But sometimes it is convenient to store the content directly in the routing table, e. g. to deliver a version number. </p>
<pre class="fragment">arangosh&gt; app.mountStaticContent("/version", { 
........&gt;   version: "1.2.3", major: 1, minor: 2, patch: 3 });
[ArangoApp "org.example.simple" at ""]
</pre><p>Save the application </p>
<pre class="fragment">arangosh&gt; app.save();
[ArangoApp "org.example.simple" at ""]
</pre><p>and use the browser to check the result </p>
<pre class="fragment">http://localhost:8529/version
</pre><p>You can also specify the content-type </p>
<pre class="fragment">arangosh&gt; app.mountStaticContent("/author", 
........&gt;                        "Frank Celler",
........&gt;                        "text/plain").save();
[ArangoApp "org.example.simple" at ""]
</pre><p>and check at </p>
<pre class="fragment">http://localhost:8529/author
</pre><p>If you have more than one application, putting version under <code>/</code> might lead to conflicts. It is therefore possible to use a common prefix for the application. </p>
<pre class="fragment">arangosh&gt; app.setPrefix("/example").save();
[ArangoApp "org.example.simple" at "/example"]
</pre><p>Now check </p>
<pre class="fragment">http://localhost:8529/example/version
http://localhost:8529/example/author
</pre><h3><a class="anchor" id="UserManualActionsDeployingStaticPages"></a>
Deploying Static Pages</h3>
<p>Most of the time, static html pages and JavaScript content will be delivered by your web-server. But sometimes it is convenient to deliver these directly from within ArangoDB. For example, to provide a small admin interface for you application.</p>
<p>Assume that all data is stored underneath a directory "/tmp/example" and we want to store the content in a collection "org_example_simple_content".</p>
<p>First connect the url path to the collection. </p>
<pre class="fragment">arangosh&gt; app.mountStaticPages("/static", "org_example_simple_content").save();
[ArangoApp "org.example.simple" at "/example"]
</pre><p>Next create a file <code>index.html</code> at `/tmp/example/index.html". </p>
<pre class="fragment">&lt;html&gt;
  &lt;body&gt;
    Hello World!
  &lt;/body&gt;
&lt;/html&gt;
</pre><p>Create the collection and upload this into the collection </p>
<pre class="fragment">arangosh&gt; require("org/arangodb").db._createDocumentCollection("org_example_simple_content");
[ArangoCollection 224910918055, "org_example_simple_content" (type document, status loaded)]

arangosh&gt; app.uploadStaticPages("/static", "/tmp/example");
imported '/index.html' of type 'text/html; charset=utf-8'
[ArangoApp "org.example.simple" at "/example"]
</pre><p>Check the index file </p>
<pre class="fragment">http://localhost:8529/example/static/index.html
</pre><h3><a class="anchor" id="UserManualActionsDeployingModules"></a>
Deploying Modules</h3>
<p>In general deploying static pages is nice for demos and administrative front-ends; but most of the time you will deploy JavaScript functions which will compute JSON objects implementing a RESTful interface or something similar.</p>
<p>In order to deploy modules <em>not</em> belonging to a particular application use </p>
<pre class="fragment">arangosh&gt; var deploy = require("org/arangodb/deploy");

arangosh&gt; deploy.uploadModules("org/example", "/tmp/example/modules");
imported '/org/example/simple'
</pre><p>This will upload all JavaScript files - which must end in <code>.js</code> - into the database. The first argument to <code>uploadModules</code> is a prefix used for the module path.</p>
<p>For more details check the modules chapter in the reference handbook. </p>
</div></div><!-- contents -->
</div>


	  </div><!-- .entry-content -->
	</div><!-- #post-## -->


      <div id="comments">


  <p class="nocomments">Comments are closed.</p>



</div><!-- #comments -->


      </div><!-- #content -->
    </div><!-- #container -->

  <div style="clear:both;"></div>
  </div><!-- #main -->



</div><!-- #wrapper -->
</div><!-- #surrounding -->


  <div id="footer" role="contentinfo">
    <div id="colophon">




      <div id="footer-widget-area" role="complementary">

	<div id="first" class="widget-area">
	  <ul class="xoxo">
		<li id="recent-posts-4" class="widget-container widget_recent_entries">	  <h3 class="widget-title">Recent Posts</h3>	<ul>
	  <li>
	<a href="http://www.arangodb.org/2013/05/22/replication-and-sharding-in-arangodb" title="Our plans on replication and sharding in ArangoDB">Our plans on replication and sharding in ArangoDB</a>
	    </li>
	  <li>
	<a href="http://www.arangodb.org/2013/05/14/ideas-and-facts-from-scotland-js-in-edinburgh" title="Ideas and Facts from scotland.js in Edinburgh">Ideas and Facts from scotland.js in Edinburgh</a>
	    </li>
	  <li>
	<a href="http://www.arangodb.org/2013/05/12/arangodb-1-3-0-released" title="ArangoDB 1.3.0 released">ArangoDB 1.3.0 released</a>
	    </li>
	  <li>
	<a href="http://www.arangodb.org/2013/05/06/foxx-screencast-part-2" title="Foxx Screencast: Part 2">Foxx Screencast: Part 2</a>
	    </li>
	</ul>
    </li><li id="text-5" class="widget-container widget_text"><h3 class="widget-title">Documentation</h3>     <div class="textwidget"><ul>
  <li><a href="/quickstart">First step tutorial</a></li>
  <li><a href="/manuals">Manual/documentation (HTML/PDF)</a></li>
  <li><a href="/manuals/arangodb_1.0_shell_reference_card.pdf">ArangoDB Shell Reference Card (HTML/PDF)</a></li>
  <li><a href="/try">Try ArangoDB online</a></li>
  <li><a href="/api">API clients & 3rd party libs</a></li>
        <li><a href="/logos">ArangoDB artwork/logos</a></li>
</ul>
</div>
    </li><li id="text-7" class="widget-container widget_text"><h3 class="widget-title">Social Links</h3>      <div class="textwidget"><ul>
  <li><a href="https://twitter.com/arangodb">ArangoDB on Twitter</a></li>
  <li><a href="https://groups.google.com/group/arangodb">ArangoDB Google Group</a></li>
  <li><a href="http://stackoverflow.com/questions/tagged/arangodb">ArangoDB questions on StackOverflow</a></li>
  <li><a href="https://github.com/triagens/arangodb/issues?state=open">Issue Tracker at Github</a></li>
</ul></div>
    </li><li id="text-6" class="widget-container widget_text"><h3 class="widget-title">Roadmap</h3>	<div class="textwidget"><ul>
  <li><a href="/roadmap/#v1.4">Backlog for Version 1.4</a></li>
  <li><a href="/roadmap/#v1.x">Backlog for Version 1.x</a></li>
</ul></div>
    </li>	  </ul>
	</div><!-- #first .widget-area -->




      </div><!-- #footer-widget-area -->


<!-- #site-generator -->

    </div><!-- #colophon -->

        <div class="copy">
            Copyright 2013 ArangoDB | <a href="/imprint">Imprint</a>
        </div>

  </div><!-- #footer -->

</body>
</html>